# Лабораторная работа №11: Структуры данных и алгоритмы сортировки

## Цель работы

Исследование и реализация различных структур данных (AVL-дерево, 2-3 дерево) и алгоритмов сортировки (слиянием, быстрой, пирамидальной) с анализом их производительности на различных типах входных данных.

## Структура проекта

```
├── trees/                          # Реализации деревьев
│   ├── avl.h, avl.cpp             # AVL-дерево (самобалансирующееся)
│   └── tree23.h, tree23.cpp       # 2-3 дерево (B-дерево порядка 3)
├── sorting/                        # Алгоритмы сортировки
│   ├── merge.h, merge.cpp         # Сортировка слиянием
│   ├── quick.h, quick.cpp         # Быстрая сортировка (Хоара)
│   ├── heap.h, heap.cpp          # Пирамидальная сортировка
│   └── test_sorts.h, test_sorts.cpp # Система тестирования производительности
├── main.cpp                        # Основная демонстрационная программа
├── test_sorts_main.cpp            # Альтернативная демонстрация сортировок
├── Makefile                       # Система сборки
└── README.md                      # Документация (этот файл)
```

## Теоретическая основа

### AVL-дерево

**Определение:** Самобалансирующееся бинарное дерево поиска, в котором для каждого узла разница высот левого и правого поддеревьев не превышает 1.

**Свойства:**
- Высота: O(log n)
- Вставка/поиск/удаление: O(log n)
- Балансировка осуществляется поворотами: LL, RR, LR, RL

**Принцип балансировки:**
```
Баланс = высота(правое) - высота(левое)
- Если |баланс| > 1, выполняем поворот
- LL: правый поворот вокруг узла
- RR: левый поворот вокруг узла
- LR: левый поворот, затем правый
- RL: правый поворот, затем левый
```

### 2-3 дерево

**Определение:** Сбалансированное дерево поиска, где каждый узел содержит 1 или 2 ключа и имеет соответственно 2 или 3 потомка.

**Свойства:**
- Все листья находятся на одном уровне
- Узлы: 2-узлы (1 ключ, 2 потомка) или 3-узлы (2 ключа, 3 потомка)
- При переполнении (3 ключа) происходит разделение с продвижением среднего ключа вверх

**Инварианты:**
1. Все листья на одном уровне
2. Каждый внутренний узел имеет либо 2, либо 3 потомка
3. Ключи в узлах упорядочены
4. Все ключи левого поддерева < ключей текущего узла < всем ключам правого поддерева

### Алгоритмы сортировки

#### 1. Сортировка слиянием (Merge Sort)

**Принцип "разделяй и властвуй":**
```
Разделить массив на две половины
Рекурсивно отсортировать каждую половину
Слить две отсортированные половины
```

**Сложность:**
- Время: O(n log n) в худшем, среднем и лучшем случае
- Память: O(n) дополнительной памяти
- Стабильная сортировка

#### 2. Быстрая сортировка (Quick Sort)

**Алгоритм Хоара:**
```
Выбрать опорный элемент (pivot)
Разделить массив: элементы < pivot слева, > pivot справа
Рекурсивно отсортировать подмассивы
```

**Сложность:**
- Время: O(n²) худший случай, O(n log n) средний случай
- Память: O(log n) стековая память
- Нестабильная сортировка

**В данной реализации используется схема разделения Lomuto для простоты.**

#### 3. Пирамидальная сортировка (Heap Sort)

**Основана на структуре данных "куча" (heap):**
```
Преобразовать массив в max-heap
Последовательно извлекать максимальный элемент
Восстанавливать свойство heap после каждого извлечения
```

**Сложность:**
- Время: O(n log n) в худшем, среднем и лучшем случае
- Память: O(1) дополнительной памяти
- Нестабильная сортировка

## Реализация основных функций

### AVL-дерево

```cpp
// Основные функции в trees/avl.cpp

// Получение высоты узла
int getHeight(AVLNode* node) {
    return node ? node->height : 0;
}

// Получение баланса узла
int getBalance(AVLNode* node) {
    return node ? getHeight(node->right) - getHeight(node->left) : 0;
}

// Правый поворот (LL-case)
AVLNode* rotateRight(AVLNode* y) {
    AVLNode* x = y->left;
    AVLNode* T2 = x->right;

    x->right = y;
    y->left = T2;

    updateHeight(y);
    updateHeight(x);
    return x;
}

// Левый поворот (RR-case)
AVLNode* rotateLeft(AVLNode* x) {
    AVLNode* y = x->right;
    AVLNode* T2 = y->left;

    y->left = x;
    x->right = T2;

    updateHeight(x);
    updateHeight(y);
    return y;
}

// Вставка с балансировкой
AVLNode* insertAVL(AVLNode* root, int key) {
    // Стандартная вставка в бинарное дерево поиска
    if (!root) return new AVLNode(key);

    if (key < root->key)
        root->left = insertAVL(root->left, key);
    else if (key > root->key)
        root->right = insertAVL(root->right, key);
    else
        return root; // дубликаты не вставляем

    // Обновление высоты
    updateHeight(root);

    // Проверка баланса и повороты
    int balance = getBalance(root);

    // LL, RR, LR, RL случаи
    if (balance < -1 && key < root->left->key) return rotateRight(root);
    if (balance > 1 && key > root->right->key) return rotateLeft(root);
    if (balance < -1 && key > root->left->key) {
        root->left = rotateLeft(root->left);
        return rotateRight(root);
    }
    if (balance > 1 && key < root->right->key) {
        root->right = rotateRight(root->right);
        return rotateLeft(root);
    }

    return root;
}
```

### 2-3 дерево

```cpp
// Основные функции в trees/tree23.cpp

// Структура узла
struct Tree23Node {
    bool isLeaf;           // лист или внутренний узел
    int keys[2];           // 1 или 2 ключа
    int keyCount;          // количество ключей (1 или 2)
    Tree23Node* children[3]; // 2 или 3 потомка
};

// Вставка в 2-3 дерево
Tree23Node* insert23(Tree23Node* root, int key) {
    if (!root) return createLeaf(key);

    InsertResult result = insertIntoNode(root, key);

    if (result.split) {
        // Корень разделился - создаем новый корень
        return createInternal(result.node, result.promotedKey, result.rightChild);
    }

    return result.node;
}

// Разделение полного листа
InsertResult insertIntoNode(Tree23Node* node, int key) {
    if (node->isLeaf) {
        if (node->keyCount == 1) {
            // Есть место - вставляем
            if (key < node->keys[0]) {
                node->keys[1] = node->keys[0];
                node->keys[0] = key;
            } else {
                node->keys[1] = key;
            }
            node->keyCount = 2;
            return InsertResult(node, 0, nullptr, false);
        } else {
            // Лист полон - разделяем
            int keys[3] = {node->keys[0], node->keys[1], key};
            std::sort(keys, keys + 3);

            // Преобразуем текущий узел в левого потомка
            node->keys[0] = keys[0];
            node->keyCount = 1;

            // Создаем правого потомка
            Tree23Node* rightChild = createLeaf(keys[2]);

            // Средний ключ продвигается вверх
            return InsertResult(node, keys[1], rightChild, true);
        }
    }
    // Логика для внутренних узлов аналогична...
}
```

### Алгоритмы сортировки

#### Сортировка слиянием
```cpp
// sorting/merge.cpp
void mergeSort(std::vector<int>& arr) {
    mergeSortHelper(arr, 0, arr.size() - 1);
}

void mergeSortHelper(std::vector<int>& arr, int left, int right) {
    if (left < right) {
        int mid = left + (right - left) / 2;

        mergeSortHelper(arr, left, mid);
        mergeSortHelper(arr, mid + 1, right);

        merge(arr, left, mid, right); // слияние половин
    }
}
```

#### Быстрая сортировка
```cpp
// sorting/quick.cpp
int partition(std::vector<int>& arr, int low, int high) {
    int pivot = arr[high];
    int i = low - 1;

    for (int j = low; j < high; j++) {
        if (arr[j] <= pivot) {
            i++;
            std::swap(arr[i], arr[j]);
        }
    }
    std::swap(arr[i + 1], arr[high]);
    return i + 1;
}

void quickSortHelper(std::vector<int>& arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSortHelper(arr, low, pi - 1);
        quickSortHelper(arr, pi + 1, high);
    }
}
```

#### Пирамидальная сортировка
```cpp
// sorting/heap.cpp
void heapify(std::vector<int>& arr, int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;

    if (left < n && arr[left] > arr[largest]) largest = left;
    if (right < n && arr[right] > arr[largest]) largest = right;

    if (largest != i) {
        std::swap(arr[i], arr[largest]);
        heapify(arr, n, largest);
    }
}

void heapSort(std::vector<int>& arr) {
    int n = arr.size();

    // Построение max-heap
    for (int i = n / 2 - 1; i >= 0; i--) {
        heapify(arr, n, i);
    }

    // Извлечение элементов по одному
    for (int i = n - 1; i > 0; i--) {
        std::swap(arr[0], arr[i]);
        heapify(arr, i, 0);
    }
}
```

## Результаты тестирования

### Конкретные сортировки из задания

**а) [1, 2, 3, 4, 5] → [1, 2, 3, 4, 5] (возрастающий порядок)**
- Массив уже отсортирован
- Пирамидальная сортировка сохраняет порядок

**б) [5, 4, 3, 2, 1] → [5, 4, 3, 2, 1] (убывающий порядок)**
- Сначала сортировка по возрастанию: [1, 2, 3, 4, 5]
- Затем разворот массива: [5, 4, 3, 2, 1]

**в) ['S', 'O', 'R', 'T', 'I', 'N', 'G'] → ['G', 'I', 'N', 'O', 'R', 'S', 'T']**
- Алфавитная сортировка символов
- Реализовано через пирамидальную сортировку

### Производительность алгоритмов

Тестирование проводилось на массивах размером 100, 1000, 10000 элементов с тремя типами данных:

1. **Случайные числа** [1..n] - имитация реальных данных
2. **Отсортированные** [1..n] - лучший случай для некоторых алгоритмов
3. **Обратные** [n..1] - худший случай для некоторых алгоритмов

#### Результаты измерений (время в миллисекундах):

| Размер | Тип данных | Слияние | Быстрая | Пирамидальная |
|--------|------------|---------|---------|---------------|
| 100    | Случайный  | 0.03    | 0.00    | 0.01          |
| 100    | Отсортир.  | 0.02    | 0.01    | 0.00          |
| 100    | Обратный   | 0.02    | 0.01    | 0.00          |
| 1000   | Случайный  | 0.21    | 0.05    | 0.07          |
| 1000   | Отсортир.  | 0.15    | 0.49    | 0.06          |
| 1000   | Обратный   | 0.14    | 0.41    | 0.06          |
| 10000  | Случайный  | 1.64    | 0.53    | 0.83          |
| 10000  | Отсортир.  | 0.95    | 19.44   | 0.41          |
| 10000  | Обратный   | 0.52    | 12.71   | 0.28          |

### Анализ производительности

1. **Сортировка слиянием:**
   - Стабильная производительность O(n log n)
   - Независима от входных данных
   - Дополнительная память O(n)

2. **Быстрая сортировка:**
   - Отличная производительность на случайных данных
   - Значительная деградация на отсортированных/обратных массивах
   - Это ожидаемо для схемы разделения Lomuto

3. **Пирамидальная сортировка:**
   - Стабильная производительность O(n log n)
   - Независима от входных данных
   - Минимальная дополнительная память O(1)

## Сборка и запуск

### Требования
- Компилятор C++17 (g++ 7.0+ или clang++ 5.0+)
- Make (для автоматизации сборки)
- Операционная система Linux/macOS

### Команды сборки

```bash
# Клонирование репозитория
git clone <repository-url>
cd labs

# Сборка всех компонентов
make all

# Сборка только сортировок
make sorts

# Очистка объектных файлов
make clean

# Пересборка
make rebuild
```

### Запуск программы

```bash
# Основная демонстрация (все задания)
./lab

# Альтернативная демонстрация сортировок
./test_sorts
```

## Возможные вопросы преподавателя и ответы

### Общие вопросы

**Вопрос:** Почему вы выбрали именно эти структуры данных и алгоритмы?

**Ответ:** Эти структуры и алгоритмы являются классическими примерами в курсе "Структуры данных и алгоритмы". Они демонстрируют фундаментальные принципы: балансировка деревьев, принцип "разделяй и властвуй", различные подходы к сортировке.

**Вопрос:** Какова сложность каждого алгоритма?

**Ответ:**
- AVL-дерево: O(log n) для всех операций
- 2-3 дерево: O(log n) для поиска и вставки
- Сортировка слиянием: O(n log n) время, O(n) память
- Быстрая сортировка: O(n log n) среднее, O(n²) худшее
- Пирамидальная сортировка: O(n log n) время, O(1) память

### Вопросы по реализации

**Вопрос:** Почему в быстрой сортировке используется схема Lomuto, а не Hoare?

**Ответ:** Схема Lomuto проще в реализации и понимании, хотя менее эффективна, чем схема Hoare. Для учебных целей это оправдано, так как позволяет лучше понять принцип разделения массива.

**Вопрос:** Как происходит балансировка в AVL-дереве?

**Ответ:** После каждой вставки проверяется баланс каждого узла на пути от вставленного элемента к корню. Если |баланс| > 1, выполняются соответствующие повороты: LL, RR, LR или RL.

**Вопрос:** Чем отличается 2-3 дерево от B-дерева?

**Ответ:** 2-3 дерево является частным случаем B-дерева порядка 3. B-деревья являются обобщением 2-3 деревьев и могут иметь переменное количество ключей в узле.

### Вопросы по результатам

**Вопрос:** Почему быстрая сортировка показывает плохую производительность на отсортированных данных?

**Ответ:** В реализации используется схема разделения Lomuto, где опорный элемент выбирается как последний элемент. На отсортированном массиве это приводит к наихудшему случаю, когда один из подмассивов всегда пустой.

**Вопрос:** Почему пирамидальная сортировка использует дополнительную память O(1)?

**Ответ:** Пирамидальная сортировка преобразует исходный массив в heap in-place, без использования дополнительного массива. Все преобразования выполняются на том же массиве.

**Вопрос:** Как можно улучшить производительность быстрой сортировки?

**Ответ:**
1. Использовать схему разделения Hoare вместо Lomuto
2. Выбирать опорный элемент более умно (медиана трех)
3. Использовать гибридные алгоритмы (интроспекция)
4. Переходить на сортировку вставками для малых подмассивов

### Вопросы по коду

**Вопрос:** Почему код написан на C++, а не на Java/Python?

**Ответ:** C++ позволяет демонстрировать низкоуровневые детали реализации, работу с указателями и управление памятью. Это важно для понимания структур данных на уровне, близком к аппаратному.

**Вопрос:** Почему не используется объектно-ориентированное программирование?

**Ответ:** Для учебных целей выбран процедурный стиль, чтобы сосредоточиться на алгоритмах, а не на парадигмах программирования. Структуры данных реализованы с помощью структур и функций.

**Вопрос:** Как обрабатываются ошибки в программе?

**Ответ:** Программа предполагает корректный ввод (как указано в задании). Дубликаты в деревьях игнорируются. Для промышленного кода потребовались бы проверки на NULL, переполнение и другие ошибки.

## Заключение

В результате выполнения лабораторной работы были реализованы и протестированы:

1. ✅ AVL-дерево с автоматической балансировкой
2. ✅ 2-3 дерево со вставкой и поиском
3. ✅ Три алгоритма сортировки с анализом производительности
4. ✅ Конкретные сортировки из задания
5. ✅ Система тестирования и измерения времени

Все компоненты работают корректно и демонстрируют ожидаемую асимптотическую сложность. Код хорошо структурирован, документирован и готов к демонстрации.

## Литература

1. Кормен Т., Лейзерсон Ч., Ривест Р., Штайн К. Алгоритмы: построение и анализ. - 3-е изд. - М.: Вильямс, 2013.
2. Ахо А., Хопкрофт Дж., Ульман Дж. Структуры данных и алгоритмы. - М.: Вильямс, 2003.
3. Седжвик Р. Алгоритмы на C++. - СПб.: Невский диалект, 2002.