# Лабораторная работа 8. Сравнительный анализ алгоритмов поиска пути A*, A*PS и Theta*

## Теоретическая часть

### Постановка задачи
Планирование оптимальной трассы для гоночного дрона в заброшенном цехе с обходом колонн и оборудования. Требуется сравнить три алгоритма поиска пути по различным метрикам качества.

### Алгоритмы поиска пути

#### 1. Алгоритм A*
**Принцип работы:**
- Комбинирует жадный поиск по первому наилучшему соответствию и поиск по критерию стоимости
- Использует эвристическую функцию f(n) = g(n) + h(n), где:
  - g(n) - стоимость пути от начальной точки до n
  - h(n) - эвристическая оценка стоимости от n до цели
- Поддерживает два множества: открытое (кандидаты) и закрытое (обработанные узлы)

**Преимущества:**
- Гарантированно находит оптимальный путь
- Эффективен благодаря эвристике

**Недостатки:**
- Создает угловатые, "зубчатые" пути
- Требует памяти для хранения всех рассматриваемых узлов

#### 2. Алгоритм A*PS (A* с пост-сглаживанием)
**Принцип работы:**
1. Выполняется стандартный алгоритм A*
2. Полученный путь подвергается пост-обработке:
   - Проверяется прямая видимость между точками пути
   - Удаляются промежуточные точки, если есть прямая видимость

**Преимущества:**
- Улучшает плавность пути
- Минимальные вычислительные затраты
- Сохраняет оптимальность базового A*

**Недостатки:**
- Не всегда находит глобально оптимальный сглаженный путь

#### 3. Алгоритм Theta*
**Принцип работы:**
- Модификация A*, позволяющая "перепрыгивать" через углы
- При расширении узла проверяется прямая видимость от родителя к соседу
- Если видимость есть, узел соединяется непосредственно с родителем родителя

**Преимущества:**
- Создает значительно более плавные пути
- Часто находит более короткие маршруты
- Особенно эффективен в открытых пространствах

**Недостатки:**
- Требует больше вычислений для проверки видимости
- Может быть менее эффективен в очень плотных средах

### Метрики оценки качества

#### 1. Метрики оптимальности пути
- **Коэффициент оптимальности (КО)**: L_найденный / L_оптимальный
- **Отклонение от оптимального пути (ОО)**: (L_найденный - L_оптимальный) / L_оптимальный × 100%
- **Суммарный угол поворотов (СУП)**: Σ |θ_i - θ_(i-1)|
- **Гладкость пути (ГП)**: СУП / (n-1)

#### 2. Вычислительная эффективность
- **Эффективность поиска**: L_оптимальный / N_раскрытых
- **Фактор ветвления**: N_раскрытых^(1/d)

#### 3. Качество траектории
- **Минимальное расстояние до препятствий**
- **Среднее расстояние до препятствий**
- **Кривизна пути**

## Структура проекта

```
lab8/
├── main.cpp              # Главная функция программы
├── graph.h               # Структуры данных для графа и карты
├── algorithms.h          # Заголовочные файлы алгоритмов
├── algorithms.cpp        # Реализации алгоритмов A*, A*PS, Theta*
├── metrics.h             # Заголовочные файлы метрик
├── metrics.cpp           # Реализации вычисления метрик
├── tests.h               # Заголовочные файлы тестов
├── tests.cpp             # Тестовые сценарии и запуск тестов
├── utils.h               # Вспомогательные функции
├── utils.cpp             # Реализации вспомогательных функций
└── Makefile              # Файл для сборки проекта
```

## Принцип работы основных функций

### Структуры данных

#### Point
```cpp
struct Point {
    int x, y;
    double distance(const Point& other) const;
    bool operator==(const Point& other) const;
};
```
- Представляет точку в 2D пространстве
- `distance()` вычисляет Евклидово расстояние между точками
- Оператор `==` позволяет сравнивать точки на равенство

#### Node
```cpp
struct Node {
    Point pos;
    double g, h, f;
    Node* parent;
};
```
- Узел для алгоритма поиска пути
- `g` - стоимость пути от старта
- `h` - эвристическая оценка до цели
- `f` = g + h - общий приоритет
- `parent` - ссылка на родительский узел

#### Map
```cpp
class Map {
    bool isObstacle(int x, int y) const;
    bool isLineOfSight(const Point& from, const Point& to) const;
    void addObstacle(int x, int y);
};
```
- Представляет карту с препятствиями
- `isLineOfSight()` проверяет прямую видимость между точками (алгоритм Брезенхема)

### Ключевые функции

#### Алгоритм A* (`aStar()`)
```cpp
std::vector<Point> aStar(const Point& start, const Point& goal, const Map& map, int& nodesExplored)
```
1. Инициализация открытого множества с начальным узлом
2. Цикл пока открытое множество не пусто:
   - Извлечение узла с минимальным f
   - Проверка достижения цели
   - Генерация соседей
   - Обновление стоимостей и приоритетов
3. Восстановление пути через родительские ссылки

#### Алгоритм A*PS (`aStarPS()`)
```cpp
std::vector<Point> aStarPS(const Point& start, const Point& goal, const Map& map, int& nodesExplored)
```
1. Вызов базового A* для получения начального пути
2. Пост-сглаживание:
   - Проход по точкам пути
   - Проверка прямой видимости между текущей и последующими точками
   - Удаление промежуточных точек при наличии видимости

#### Алгоритм Theta* (`thetaStar()`)
```cpp
std::vector<Point> thetaStar(const Point& start, const Point& goal, const Map& map, int& nodesExplored)
```
1. Аналогично A*, но с модификацией при расширении узлов
2. Для каждого соседа проверяется:
   - Прямая видимость от родителя текущего узла к соседу
   - Если видимость есть - соединение с родителем родителя
   - Иначе - стандартное соединение через текущий узел

#### Вспомогательные функции

##### Эвристика (`heuristic()`)
```cpp
double heuristic(const Point& a, const Point& b) {
    return a.distance(b);
}
```
- Использует Евклидово расстояние как допустимую эвристику

##### Получение соседей (`getNeighbors()`)
```cpp
std::vector<Point> getNeighbors(const Point& p, const Map& map)
```
- Возвращает 8 соседних точек (8-связная сетка)
- Фильтрует невалидные точки и препятствия

##### Проверка видимости (`bresenhamLineOfSight()`)
```cpp
bool bresenhamLineOfSight(const Point& start, const Point& end, const Map& map)
```
- Реализация алгоритма Брезенхема для рисования линии
- Проверяет каждую точку линии на наличие препятствий

### Метрики качества

#### Длина пути (`pathLength()`)
```cpp
double pathLength(const std::vector<Point>& path)
```
- Суммирует расстояния между последовательными точками пути

#### Суммарный угол поворотов (`totalTurningAngle()`)
```cpp
double totalTurningAngle(const std::vector<Point>& path)
```
- Вычисляет углы между последовательными сегментами пути
- Использует скалярное произведение векторов

#### Гладкость пути (`pathSmoothness()`)
```cpp
double pathSmoothness(const std::vector<Point>& path)
```
- Средний угол поворота на сегмент пути

## Инструкция по сборке и запуску

### Требования
- Компилятор с поддержкой C++11 (g++ 4.8+)
- Операционная система: Linux, Windows (WSL), macOS

### Сборка проекта
```bash
cd lab8
make
```

### Запуск тестов
```bash
./lab8
```

### Очистка проекта
```bash
make clean
```

## Тестовые сценарии

### 1. Открытое пространство
- **Цель**: Проверить работу в простых условиях
- **Ожидание**: Все алгоритмы должны найти прямой оптимальный путь

### 2. Улучшенный лабиринт
- **Цель**: Проверить навигацию в структурированной среде
- **Ожидание**: Алгоритмы должны найти обходные пути через проходы

### 3. Множество препятствий
- **Цель**: Проверить работу в плотной среде
- **Ожидание**: Theta* должен показать лучшую гладкость пути

### 4. Узкие коридоры
- **Цель**: Проверить навигацию в ограниченном пространстве
- **Ожидание**: Все алгоритмы должны успешно пройти коридор

## Результаты и выводы

### Ключевые наблюдения

1. **Theta*** демонстрирует наилучшее качество пути за счет проверки прямой видимости
2. **A*PS** эффективно улучшает плавность пути с минимальными затратами
3. **A*** остается надежным базовым алгоритмом для простых сценариев

### Рекомендации по применению

- **Для гоночных дронов**: Theta* (лучшая плавность траектории)
- **Для роботов с ограничениями по вычислениям**: A*PS (баланс качества и производительности)
- **Для простых навигационных задач**: A* (надежность и предсказуемость)

### Парето-оптимальность

- **Скорость вычислений**: A*
- **Баланс качества и производительности**: A*PS
- **Качество траектории**: Theta*

Данная работа демонстрирует важность выбора подходящего алгоритма поиска пути в зависимости от требований конкретного приложения и характеристик среды.
