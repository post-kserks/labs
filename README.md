# Лабораторная работа (Пирамидальная сортировка)

## Ответы на вопросы

### Задача 1.в: Всегда ли восходящий и нисходящий алгоритмы построения пирамиды дают одну и ту же пирамиду?

**Ответ: НЕТ, не всегда.**

**Обоснование:**
В нашем эксперименте для набора чисел `{1, 8, 6, 5, 3, 7, 4}`:
1. **Восходящий метод** (последовательная вставка) дал результат:  
   `[8, 5, 7, 1, 3, 6, 4]` (примерно, проверим точный вывод программы).
   Здесь элементы добавляются по одному, и каждый новый "всплывает".
   
2. **Нисходящий метод** (sift_down всего массива) дал результат:  
   `[8, 5, 7, 1, 3, 6, 4]` — в данном конкретном случае они могут совпасть, НО:

*Пример когда не совпадают*:
Рассмотрим массив `[1, 2, 3]`.
- Нисходящий (heapify): 
    - `[1, 2, 3]` -> корень 1 меньше детей. Меняем с 3 (наибольший ребенок).
    - Результат: `[3, 2, 1]`.
- Восходящий (вставки):
    - Вставляем 1 -> `[1]`
    - Вставляем 2 -> `[1, 2]` -> sift_up(2) -> `[2, 1]`
    - Вставляем 3 -> `[2, 1, 3]` -> sift_up(3) -> `[3, 1, 2]`
    - Результат: `[3, 1, 2]`.

`[3, 2, 1]` != `[3, 1, 2]`. Оба являются валидными max-heap, но массивы разные.

---

### Задача 7: Является ли пирамидальная сортировка устойчивой?

**Ответ: НЕТ, пирамидальная сортировка НЕ является устойчивой.**

**Доказательство:**
Сортировка называется *устойчивой*, если она не меняет относительный порядок равных элементов.

Рассмотрим пример max-heap сортировки.
Пусть у нас есть массив пар (значение, индекс), чтобы различать равные элементы:
`[(2, A), (2, B), (1, C)]`

1. Построим кучу (max-heap).
   Массив уже почти куча, но корень (2, A) может поменяться местами с детьми при построении, или при самой сортировке.
   
   Более простой пример сбоя устойчивости происходит на этапе извлечения корня ("удаления максимума").
   В Heap Sort мы меняем корень (максимум) с *последним* элементом массива.
   
   Пусть куча: `[(10, A), (10, B), (5, C)]`
   1. Извлекаем максимум `(10, A)`.
      - Меняем `(10, A)` с `(5, C)`.
      - Массив: `[(5, C), (10, B), (10, A)]` (где `(10, A)` уже в отсортированной части в конце).
      - Восстанавливаем кучу для оставшейся части `[(5, C), (10, B)]`. `5` меньше `10`, меняем местами.
      - Куча: `[(10, B), (5, C)]`.
   2. Извлекаем максимум `(10, B)`.
      - Меняем `(10, B)` с `(5, C)`.
      - Массив: `[(5, C), (10, B), (10, A)]`.
   
   Результат сортировки (по возрастанию, читаем с конца или если мы формируем sorted array):
   В конце массива у нас лежат `(10, B)` затем `(10, A)`.
   То есть порядок стал `B`, `A`. А исходный был `A`, `B`.
   
   Так как обмен корня с последним элементом структуры — это "дальний прыжок", он нарушает относительный порядок равных элементов. Поэтому Heap Sort **неустойчива**.
