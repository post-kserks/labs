# Деревья поиска: AVL и красно-черные деревья - Кейс 2

## Теория

### Бинарные деревья поиска (BST)

Бинарное дерево поиска — это дерево, в котором каждый узел имеет не более двух потомков, и для каждого узла выполняется условие:
- Все ключи в левом поддереве меньше ключа узла
- Все ключи в правом поддереве больше ключа узла

Основные операции: вставка, удаление, поиск. В среднем случае они выполняются за O(log n), но в худшем случае (например, при вставке отсортированных данных) дерево вырождается в связный список с O(n).

### Сбалансированные деревья

Чтобы избежать вырождения, используются сбалансированные деревья, которые автоматически поддерживают высоту O(log n).

#### AVL-дерево

AVL-дерево — это сбалансированное по высоте бинарное дерево поиска. Для каждого узла разница высот левого и правого поддеревьев (баланс) не превышает 1. Балансировка достигается с помощью вращений (одинарных или двойных) после вставки или удаления.

**Преимущества:**
- Строгая сбалансированность, обеспечивающая эффективный поиск

**Недостатки:**
- Требует дополнительной памяти для хранения высоты каждого узла
- Частые балансировки при вставках/удалениях

#### Красно-черное дерево (RBT)

Красно-черное дерево — это бинарное дерево поиска с дополнительными битами цвета (красный или черный) для каждого узла. Оно удовлетворяет свойствам:
1. Каждый узел либо красный, либо черный
2. Корень черный
3. Все листья (NIL) черные
4. Если узел красный, то оба его потомка черные
5. Для каждого узла все пути от него до листьев содержат одинаковое количество черных узлов

**Преимущества:**
- Меньше вращений при вставке/удалении по сравнению с AVL
- Эффективность при частых вставках и удалениях

**Недостатки:**
- Менее сбалансировано, чем AVL, поэтому поиск может быть немного медленнее

### Постановка задачи (Кейс 2)

Сравнить производительность AVL и красно-черных деревьев в трех сценариях:
1. **Словарь**: 80% поиск, 20% вставка
2. **Кеш сессий**: 50% поиск, 30% вставка, 20% удаление
3. **Логирование**: 10% поиск, 90% вставка

Определить, какая структура данных лучше подходит для каждого сценария.

## Структура проекта

```
project/
├── include/
│   ├── avl_tree.h
│   ├── rbt_tree.h
│   ├── scenario_tests.h
│   └── common.h
├── src/
│   ├── avl_tree.cpp
│   ├── rbt_tree.cpp
│   ├── scenario_tests.cpp
│   └── main.cpp
├── data/
│   └── input_data.txt
├── obj/
├── bin/
└── Makefile
```

## Описание функций и методов

### common.h

Содержит общие определения и структуры.

**Структуры:**
- `AVLNode`: узел AVL-дерева (ключ, указатели на левого и правого потомка, высота)
- `RBTNode`: узел красно-черного дерева (ключ, указатели на левого, правого потомка и родителя, цвет)
- `TestResult`: результаты теста (время и высота для AVL и RBT)

**Перечисления:**
- `OperationType`: тип операции (поиск, вставка, удаление)

**Константы:**
- `NUM_OPERATIONS`: количество операций в тесте (10000)
- `DATA_RANGE`: диапазон генерируемых данных (1-1000)

### avl_tree.h / avl_tree.cpp

**Функции:**

1. `AVLNode* create_avl_node(int key)`
   - Создает новый узел AVL-дерева с заданным ключом
   - Пример:
     ```cpp
     AVLNode* node = create_avl_node(10);
     ```

2. `int get_height(AVLNode* node)`
   - Возвращает высоту узла (0 для nullptr)
   - Пример:
     ```cpp
     int h = get_height(root);
     ```

3. `void update_height(AVLNode* node)`
   - Обновляет высоту узла на основе высот потомков
   - Пример:
     ```cpp
     update_height(root);
     ```

4. `int get_balance(AVLNode* node)`
   - Вычисляет баланс-фактор узла (разность высот левого и правого поддеревьев)
   - Пример:
     ```cpp
     int balance = get_balance(root);
     ```

5. `AVLNode* rotate_right(AVLNode* y)`
   - Выполняет правое вращение вокруг узла `y`
   - Пример:
     ```cpp
     AVLNode* new_root = rotate_right(y);
     ```

6. `AVLNode* rotate_left(AVLNode* x)`
   - Выполняет левое вращение вокруг узла `x`
   - Пример:
     ```cpp
     AVLNode* new_root = rotate_left(x);
     ```

7. `AVLNode* balance_avl(AVLNode* node)`
   - Балансирует узел, если баланс-фактор нарушен
   - Пример:
     ```cpp
     AVLNode* balanced = balance_avl(node);
     ```

8. `AVLNode* avl_insert(AVLNode* root, int key)`
   - Вставляет ключ в AVL-дерево и балансирует его
   - Пример:
     ```cpp
     root = avl_insert(root, 5);
     ```

9. `AVLNode* avl_search(AVLNode* root, int key)`
   - Ищет ключ в AVL-дереве
   - Пример:
     ```cpp
     AVLNode* found = avl_search(root, 5);
     ```

10. `void free_avl_tree(AVLNode* root)`
    - Освобождает память, занятую AVL-деревом
    - Пример:
      ```cpp
      free_avl_tree(root);
      ```

### rbt_tree.h / rbt_tree.cpp

**Функции:**

1. `RBTNode* create_rbt_node(int key)`
   - Создает новый узел красно-черного дерева (красный по умолчанию)
   - Пример:
     ```cpp
     RBTNode* node = create_rbt_node(10);
     ```

2. `RBTNode* rbt_rotate_left(RBTNode* root, RBTNode* x)`
   - Выполняет левое вращение вокруг узла `x` в красно-черном дереве
   - Пример:
     ```cpp
     root = rbt_rotate_left(root, x);
     ```

3. `RBTNode* rbt_rotate_right(RBTNode* root, RBTNode* y)`
   - Выполняет правое вращение вокруг узла `y` в красно-черном дереве
   - Пример:
     ```cpp
     root = rbt_rotate_right(root, y);
     ```

4. `RBTNode* rbt_insert_fixup(RBTNode* root, RBTNode* z)`
   - Исправляет свойства красно-черного дерева после вставки узла `z`
   - Пример:
     ```cpp
     root = rbt_insert_fixup(root, z);
     ```

5. `RBTNode* rbt_insert(RBTNode* root, int key)`
   - Вставляет ключ в красно-черное дерево и исправляет свойства
   - Пример:
     ```cpp
     root = rbt_insert(root, 5);
     ```

6. `RBTNode* rbt_search(RBTNode* root, int key)`
   - Ищет ключ в красно-черном дереве
   - Пример:
     ```cpp
     RBTNode* found = rbt_search(root, 5);
     ```

7. `void free_rbt_tree(RBTNode* root)`
   - Освобождает память, занятую красно-черным деревом
   - Пример:
     ```cpp
     free_rbt_tree(root);
     ```

8. `int get_rbt_height(RBTNode* root)`
   - Вычисляет высоту красно-черного дерева
   - Пример:
     ```cpp
     int h = get_rbt_height(root);
     ```

### scenario_tests.h / scenario_tests.cpp

**Функции:**

1. `void generate_random_data(int* data, int size, int range)`
   - Заполняет массив `data` случайными числами в диапазоне [1, range]
   - Пример:
     ```cpp
     int data[100];
     generate_random_data(data, 100, 1000);
     ```

2. `TestResult test_dictionary_scenario()`
   - Тестирует сценарий "Словарь" (80% поиск, 20% вставка)
   - Возвращает структуру `TestResult` с временем и высотами

3. `TestResult test_cache_scenario()`
   - Тестирует сценарий "Кеш сессий" (50% поиск, 30% вставка, 20% удаление)
   - Возвращает структуру `TestResult`

4. `TestResult test_logging_scenario()`
   - Тестирует сценарий "Логирование" (10% поиск, 90% вставка)
   - Возвращает структуру `TestResult`

5. `void run_all_tests()`
   - Запускает все тесты и выводит результаты

### main.cpp

- Точка входа в программу
- Запускает тесты и выводит выводы для системы "Умный дом"

## Сборка и запуск

### Требования
- Компилятор с поддержкой C++17 (g++ 7 и выше)
- Make

### Инструкция

1. Создайте структуру папок:
```bash
mkdir -p project/{include,src,data,obj,bin}
```

2. Поместите файлы в соответствующие папки

3. Сборка проекта:
```bash
cd project
make
```

4. Запуск программы:
```bash
make run
```

5. Очистка:
```bash
make clean
```

## Пример вывода программы

```
=== КЕЙС 2: СРАВНЕНИЕ AVL И КРАСНО-ЧЕРНЫХ ДЕРЕВЬЕВ ===
Цель: анализ производительности в различных сценариях
=====================================================

=== ТЕСТИРОВАНИЕ СЦЕНАРИЕВ ===

1. СЦЕНАРИЙ 'СЛОВАРЬ' (80% поиск, 20% вставка):
AVL - Время: 0.005с, Высота: 15
RBT - Время: 0.007с, Высота: 17
ПОБЕДИТЕЛЬ: AVL

2. СЦЕНАРИЙ 'КЕШ СЕССИЙ' (50% поиск, 30% вставка, 20% удаление):
AVL - Время: 0.008с, Высота: 16
RBT - Время: 0.006с, Высота: 18
ПОБЕДИТЕЛЬ: RBT

3. СЦЕНАРИЙ 'ЛОГИРОВАНИЕ' (10% поиск, 90% вставка):
AVL - Время: 0.010с, Высота: 14
RBT - Время: 0.008с, Высота: 16
ПОБЕДИТЕЛЬ: RBT

=== АНАЛИЗ РЕЗУЛЬТАТОВ ===
AVL лучше для сценариев с частым поиском
RBT лучше для сценариев с частыми вставками/удалениями

=== ВЫВОДЫ ДЛЯ СИСТЕМЫ 'УМНЫЙ ДОМ' ===
Рекомендуемые структуры данных:
1. Красно-черное дерево (RBT)
2. B-дерево
3. 2-3 дерево
Обоснование: RBT лучше справляется с частыми вставками
при ограниченной памяти, что характерно для умного дома.
```

## Заключение

Данный проект демонстрирует сравнение двух сбалансированных деревьев поиска (AVL и красно-черных) в различных сценариях. Результаты показывают, что AVL деревья лучше подходят для задач с преобладанием поиска, а красно-черные — для задач с частыми вставками и удалениями.

Для системы "Умный дом", где преобладают вставки (постоянные показания сенсоров) и ограничена память, рекомендуется использовать красно-черные деревья.
