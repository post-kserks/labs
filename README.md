# Умножение матриц - Ручное управление памятью в C++

## Описание проекта

Программа демонстрирует работу с динамическими двумерными массивами в C++ с ручным управлением памятью. Пользователь вводит две матрицы, программа вычисляет их поэлементное произведение и выводит результат. Проект включает как основную программу, так и комплексную систему тестирования.

## Функциональность

### Основная программа (`main.cpp`)
- Запрос размеров матриц (количество строк и столбцов)
- Динамическое создание двух матриц A и B
- Ввод элементов матриц с клавиатуры
- Вычисление матрицы C, где каждый элемент C[i][j] = A[i][j] * B[i][j]
- Вывод результирующей матрицы
- Корректное освобождение всей выделенной памяти

### Тестовая программа (`test.cpp`)
- Комплексное тестирование всех аспектов программы
- 7 различных тестовых сценариев
- Проверка управления памятью
- Детальная отчетность о результатах

## Требования

- Компилятор C++ с поддержкой стандарта C++11 или новее
- Операционная система: Linux, Windows или macOS
- Минимальный объем оперативной памяти: 512 MB

## Структура проекта

```
project/
├── main.cpp          # Основная программа
├── test.cpp          # Тестовая программа
└── README.md         # Документация
```

## Компиляция и запуск

### Компиляция основной программы:
```bash
g++ -o matrix_multiplier main.cpp -std=c++11
```

### Запуск основной программы:
```bash
./matrix_multiplier
```

### Компиляция тестовой программы:
```bash
g++ -o test_program test.cpp -std=c++11
```

### Запуск тестов:
```bash
./test_program
```

## Пример использования основной программы

```
Enter number of rows: 2
Enter number of columns: 2
Enter elements for matrix A:
1 2
3 4
Enter elements for matrix B:
5 6
7 8
Result matrix C:
5 12
21 32
```

## Пример вывода тестовой программы

```
=== ТЕСТИРОВАНИЕ ПРОГРАММЫ УМНОЖЕНИЯ МАТРИЦ ===

Тест 1: Умножение положительных чисел... ПРОЙДЕН
Тест 2: Умножение с отрицательными числами... ПРОЙДЕН
Тест 3: Умножение с нулями... ПРОЙДЕН
Тест 4: Матрица 1x1... ПРОЙДЕН
Тест 5: Прямоугольная матрица 3x2... ПРОЙДЕН
Тест 6: Большая матрица 10x10... ПРОЙДЕН
Тест 7: Проверка управления памятью... ПРОЙДЕН (косвенная проверка)

=== РЕЗУЛЬТАТЫ ТЕСТИРОВАНИЯ ===
Пройдено тестов: 7 из 7
✅ ВСЕ ТЕСТЫ ПРОЙДЕНЫ УСПЕШНО!
```

## Тестовые сценарии

### Тест 1: Умножение положительных чисел
Проверяет базовую функциональность с положительными числами.

### Тест 2: Умножение с отрицательными числами
Проверяет корректность работы с отрицательными значениями.

### Тест 3: Умножение с нулями
Проверяет обработку нулевых элементов.

### Тест 4: Матрица 1x1
Граничный случай - матрица из одного элемента.

### Тест 5: Прямоугольная матрица 3x2
Проверяет работу с неквадратными матрицами.

### Тест 6: Большая матрица 10x10
Тестирование производительности и корректности на большой матрице.

### Тест 7: Проверка управления памятью
Косвенная проверка отсутствия утечек памяти.

## Особенности реализации

### Управление памятью
Программа использует исключительно ручное управление памятью:
- Выделение памяти через `new[]`
- Освобождение памяти через `delete[]`
- Соблюдение парности операторов `new[]`/`delete[]`
- Освобождение памяти в обратном порядке выделению

### Запрещенные технологии
В соответствии с требованиями задания не используются:
- STL-контейнеры (vector, array и т.д.)
- Умные указатели (unique_ptr, shared_ptr)
- Классы и ООП для управления памятью

### Защитное программирование
- Проверка корректности введенных размеров матриц
- Обнуление указателей после освобождения памяти
- Структурированное освобождение ресурсов

## Структура памяти

```
int** A → [int*] → [int][int][int]... (строка 0)
          [int*] → [int][int][int]... (строка 1)
          ...
```

## Важные особенности

### Порядок освобождения памяти:
1. Сначала удаляются все строки матриц
2. Затем удаляются массивы указателей

### Безопасность:
- После удаления указатели обнуляются
- Исключаются висячие указатели
- Проверка на nullptr перед удалением

### Чистота кода:
- Логичное разделение на этапы
- Понятные названия переменных
- Комментарии для ключевых блоков

## Рекомендации по использованию

1. **Для обучения**: Изучите код основной программы чтобы понять принципы ручного управления памятью
2. **Для проверки**: Запустите тестовую программу чтобы убедиться в корректности реализации
3. **Для расширения**: Можете добавить дополнительные тесты или функциональность

## Возможные улучшения

- Добавление обработки ошибок ввода
- Реализация записи результатов в файл
- Добавление поддержки других арифметических операций
- Создание графического интерфейса

## Автор

Проект выполнен в рамках изучения ручного управления памятью в C++.

## Лицензия

Образовательный проект. Свободное использование для учебных целей.

---

**Примечание**: Этот проект демонстрирует фундаментальные принципы управления памятью в C++. В реальных проектах рекомендуется использовать умные указатели и STL-контейнеры для автоматического управления ресурсами.
