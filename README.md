# Лабораторная работа по алгоритмам

**Дисциплина:** Алгоритмы и структуры данных  

---

## Описание проекта

Данная лабораторная работа содержит реализации трех алгоритмических задач на языке C++:

1. **Поиск медианы с предварительной сортировкой** (Задача 1)
2. **Поиск пересечения множеств** (Задача 3)
3. **Поиск минимального и максимального элементов** (Задача 4)

Проект демонстрирует различные подходы к решению задач, сравнение эффективности алгоритмов и правильное определение асимптотической сложности.

---

## Структура проекта

```
├── main.cpp           # Точка входа, демонстрация всех алгоритмов
├── median.h/.cpp      # Задача 1: Поиск медианы
├── intersection.h/.cpp # Задача 3: Пересечение множеств
├── minmax.h/.cpp      # Задача 4: Поиск min/max
├── Makefile           # Система сборки
└── README.md          # Документация
```

---

## Теоретическая часть

### Задача 1: Поиск медианы с предварительной сортировкой

**Определение медианы:** Медианой множества из n чисел называется элемент, стоящий в позиции ⌊n/2⌋ в упорядоченном по возрастанию массиве.

**Алгоритм:**
1. Отсортировать массив по возрастанию
2. Вернуть элемент с индексом `n/2` (целочисленное деление)

**Асимптотическая сложность:** O(n log n)
- Доминирующая операция: сортировка массива
- Доступ к элементу: O(1)

**Пример:**
```
Вход: [7, 2, 9, 4, 1, 8, 3, 6, 5]
После сортировки: [1, 2, 3, 4, 5, 6, 7, 8, 9]
Медиана: элемент с индексом 9/2 = 4 → значение 5
```

### Задача 3: Пересечение множеств

**Определение:** Пересечением множеств A и B называется множество элементов, принадлежащих одновременно обоим множествам.

#### Алгоритм а): Метод грубой силы
**Принцип работы:**
- Для каждого элемента из множества A проверить его наличие в множестве B
- При обнаружении совпадения добавить элемент в результат
- Исключить дубликаты в результате

**Асимптотическая сложность:** O(n × m)
- n = |A|, m = |B|
- В худшем случае: каждый элемент A проверяется со всеми элементами B

**Достоинства:** Простота реализации, работает с любыми типами данных
**Недостатки:** Квадратичная сложность, неэффективен для больших множеств

#### Алгоритм б): Метод с предварительной сортировкой
**Принцип работы:**
1. Отсортировать оба множества
2. Использовать два указателя для одновременного прохода по отсортированным массивам
3. При равенстве элементов: добавить в результат и сдвинуть оба указателя
4. При A[i] < B[j]: сдвинуть указатель i
5. При A[i] > B[j]: сдвинуть указатель j

**Асимптотическая сложность:** O((n+m) × log max(n,m))
- Сортировка: O(n log n + m log m)
- Проход с двумя указателями: O(n + m)

**Достоинства:** Линейная сложность после сортировки, эффективен для больших множеств
**Недостатки:** Требует сортировки, работает только со сравнимыми типами данных

### Задача 4: Поиск min/max элементов

#### Алгоритм а): С предварительной сортировкой
**Принцип работы:**
1. Отсортировать массив
2. Минимальный элемент: первый элемент отсортированного массива
3. Максимальный элемент: последний элемент отсортированного массива

**Асимптотическая сложность:** O(n log n)
- Доминирующая операция: сортировка

**Достоинства:** Простота, очевидность
**Недостатки:** Избыточная сложность для данной задачи

#### Алгоритм б): Метод грубой силы (линейный поиск)
**Принцип работы:**
1. Инициализировать min = +∞, max = -∞
2. Пройти по всем элементам массива
3. Обновлять min и max при обнаружении меньшего/большего значения

**Асимптотическая сложность:** O(n)
- Один линейный проход по массиву
- Количество сравнений: 2×(n-1)

**Достоинства:** Оптимальная сложность, простота
**Недостатки:** Отсутствуют для данной задачи

#### Алгоритм в): Турнирный метод (декомпозиция)
**Принцип работы:**
1. Разделить массив на пары элементов
2. В каждой паре определить локальный минимум и максимум
3. Собрать все локальные минимумы и максимумы
4. Повторить процесс до получения глобальных min/max

**Асимптотическая сложность:** O(n)
- Теоретически: ~1.5n сравнений
- Практически: больше констант из-за накладных расходов

**Достоинства:** Минимальное количество сравнений в теории
**Недостатки:** Сложность реализации, overhead на практике

---

## Реализация

### Архитектура кода

Проект использует процедурный стиль программирования на C++ без объектно-ориентированного подхода для максимальной простоты и понятности.

### Ключевые функции

#### median.cpp
```cpp
double find_median(std::vector<double> nums) {
    if (nums.empty()) return 0.0;
    std::sort(nums.begin(), nums.end());
    size_t mid = nums.size() / 2;
    return nums[mid];
}
```

**Логика:** Сортировка + доступ по индексу. Безопасная обработка пустого массива.

#### intersection.cpp
```cpp
// Грубая сила: O(n*m)
std::vector<double> intersection_brute_force(const std::vector<double>& A, const std::vector<double>& B) {
    // Два вложенных цикла с проверкой дубликатов
}

// С сортировкой: O((n+m)log max(n,m))
std::vector<double> intersection_sorted(const std::vector<double>& A, const std::vector<double>& B) {
    // Сортировка + два указателя
}
```

**Логика грубой силы:** Полный перебор всех комбинаций элементов.
**Логика с сортировкой:** Два указателя на отсортированных массивах - классический алгоритм слияния.

#### minmax.cpp
```cpp
// С сортировкой: O(n log n)
MinMaxResult find_minmax_sorted(std::vector<double> nums) {
    std::sort(nums.begin(), nums.end());
    return {nums[0], nums.back()};
}

// Грубая сила: O(n)
MinMaxResult find_minmax_brute_force(const std::vector<double>& nums) {
    // Один проход с обновлением min/max
}

// Турнирный метод: O(n)
MinMaxResult find_minmax_tournament(const std::vector<double>& nums) {
    // Попарные сравнения с последующим объединением
}
```

**Логика:** Три разных подхода демонстрируют различные стратегии решения одной задачи.

### Система сборки

Используется GNU Make для автоматизации компиляции:

```makefile
CXX = g++-17
CXXFLAGS = -std=c++17 -O2 -Wall
TARGET = lab
SRCS = main.cpp median.cpp intersection.cpp minmax.cpp
```

**Оптимизации:** -O2 для производительности, -Wall для диагностики.

---

## Сборка и запуск

### Требования
- Компилятор GCC с поддержкой C++17
- GNU Make
- macOS/Linux/Windows с MinGW

### Команды сборки

```bash
# Сборка проекта
make

# Запуск программы
make run

# Очистка
make clean
```

### Пример вывода

```
Лабораторная работа по алгоритмам
=================================

Задача 1: Поиск медианы с предварительной сортировкой
----------------------------------------------------
Тестовый массив: [7, 2, 9, 4, 1, 8, 3, 6, 5]
Медиана: 5
Сложность: O(n log n) - сортировка

Задача 3: Пересечение множеств
------------------------------
Множество A: [1, 3, 5, 7, 9, 2]
Множество B: [2, 4, 6, 8, 1, 3]
Пересечение (грубая сила): [1, 3, 2]
Сложность грубой силы: O(n * m)
Пересечение (с сортировкой): [1, 2, 3]
Сложность с сортировкой: O((n+m) log max(n,m))

Сравнение производительности (на массиве из 10000 элементов)
-------------------------------------------------------------
Сортировка: 0.331 мс
Грубая сила: 0.019 мс
Турнирный метод: 0.112 мс
```

---

## Возможные вопросы преподавателя и ответы

### Вопрос 1: Почему для поиска медианы используется сортировка?
**Ответ:** Сортировка - наиболее естественный и понятный способ найти медиану. Хотя существуют алгоритмы за линейное время (например, QuickSelect), сортировка демонстрирует базовый подход и позволяет легко объяснить концепцию медианы. Сложность O(n log n) приемлема для большинства практических задач.

### Вопрос 2: В чем преимущество сортировки при поиске пересечения множеств?
**Ответ:** После сортировки O((n+m)log max(n,m)) мы получаем линейный алгоритм O(n+m) для поиска пересечения. Это значительно эффективнее грубой силы O(n×m) для больших множеств. Метод двух указателей является классическим алгоритмом для работы с отсортированными данными.

### Вопрос 3: Почему сортировка неэффективна для поиска min/max?
**Ответ:** Задача поиска min/max имеет оптимальную сложность O(n), достижимую за один проход по массиву. Сортировка дает O(n log n), что избыточно. Это демонстрирует важность выбора правильного алгоритма - иногда "простое" решение оказывается неэффективным.

### Вопрос 4: В чем смысл турнирного метода для min/max?
**Ответ:** Турнирный метод минимизирует количество сравнений в теории (1.5n вместо 2n). Это демонстрация декомпозиции - разделения задачи на подзадачи. В практике из-за overhead'а он может быть медленнее линейного поиска, но важен для понимания теоретических аспектов.

### Вопрос 5: Почему не используется объектно-ориентированный подход?
**Ответ:** Проект следует принципу KISS (Keep It Simple, Stupid). Процедурный стиль делает код более понятным для изучения алгоритмов, без отвлечения на концепции ООП. Это позволяет сосредоточиться на логике алгоритмов, а не на архитектуре программы.

### Вопрос 6: Как обеспечивается корректность результатов?
**Ответ:** Все алгоритмы тестируются на известных входных данных с предсказуемыми результатами. Производительность измеряется на больших массивах для демонстрации асимптотического поведения. Код содержит проверки на пустые массивы и обработку крайних случаев.

### Вопрос 7: Почему используются именно эти типы данных?
**Ответ:** `std::vector<double>` обеспечивает гибкость и совместимость с алгоритмами STL. `double` позволяет работать с вещественными числами, что делает примеры более реалистичными. Для целочисленных задач можно легко адаптировать код.

### Вопрос 8: Какова практическая применимость реализованных алгоритмов?
**Ответ:**
- **Медиана:** Статистические расчеты, обработка сигналов
- **Пересечение множеств:** Поиск общих элементов в базах данных, анализ данных
- **Min/max:** Поиск экстремумов в массивах данных, валидация данных

---

## Заключение

Данная лабораторная работа демонстрирует:
- Правильное определение асимптотической сложности алгоритмов
- Сравнение различных подходов к решению одной задачи
- Важность выбора подходящего алгоритма для конкретной задачи
- Практические аспекты реализации алгоритмов на C++

Все алгоритмы реализованы корректно, с подробными комментариями и демонстрируют ожидаемую производительность согласно теоретическим оценкам.