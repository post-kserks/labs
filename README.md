# Семинар 9: Поиск максимального подмассива

## Содержание
1. [Теоретическая часть](#теоретическая-часть)
2. [Алгоритмы реализации](#алгоритмы-реализации)
3. [Структура проекта](#структура-проекта)
4. [Инструкция по сборке и запуску](#инструкция-по-сборке-и-запуску)
5. [Результаты и анализ](#результаты-и-анализ)
6. [Выводы](#выводы)

## Теоретическая часть

### Постановка задачи
**Задача поиска максимального подмассива** (Maximum Subarray Problem) заключается в нахождении непрерывного подмассива в одномерном массиве целых чисел, сумма элементов которого является максимальной среди всех возможных подмассивов.

**Формальная постановка:**
Для массива `A[1..n]` найти индексы `i` и `j` (1 ≤ i ≤ j ≤ n) такие, что сумма `A[i] + A[i+1] + ... + A[j]` максимальна.

**Пример:**
Для массива `[-2, 1, -3, 4, -1, 2, 1, -5, 4]`
Максимальный подмассив: `[4, -1, 2, 1]` с суммой `6`

### Вычислительная сложность
- **Полный перебор:** O(n²) - квадратичная сложность
- **Алгоритм Кадане:** O(n) - линейная сложность

## Алгоритмы реализации

### 1. Метод полного перебора

#### Принцип работы
Алгоритм перебирает все возможные подмассивы, вычисляя сумму каждого из них.

```cpp
int findMaxSubarrayBruteForce(const std::vector<int>& nums) {
    int maxSum = INT_MIN;

    for (size_t i = 0; i < nums.size(); i++) {
        int currentSum = 0;
        for (size_t j = i; j < nums.size(); j++) {
            currentSum += nums[j];
            if (currentSum > maxSum) {
                maxSum = currentSum;
            }
        }
    }

    return maxSum;
}
```

**Пояснение:**
- Внешний цикл перебирает все возможные начала подмассивов
- Внутренний цикл перебирает все возможные концы подмассивов
- Для каждой пары (i, j) вычисляется сумма элементов от i до j
- Максимальная сумма обновляется при нахождении большего значения

**Сложность:** O(n²)
- Количество операций: n + (n-1) + (n-2) + ... + 1 = n(n+1)/2 ≈ n²/2

### 2. Алгоритм Кадане

#### Принцип работы
Алгоритм использует динамическое программирование для эффективного поиска максимального подмассива.

```cpp
int findMaxSubarrayOptimal(const std::vector<int>& nums) {
    if (nums.empty()) return 0;

    int maxSum = nums[0];
    int currentSum = nums[0];

    for (size_t i = 1; i < nums.size(); i++) {
        currentSum = std::max(nums[i], currentSum + nums[i]);
        maxSum = std::max(maxSum, currentSum);
    }

    return maxSum;
}
```

**Пояснение:**
- `currentSum` хранит максимальную сумму подмассива, заканчивающегося на текущем элементе
- На каждом шаге выбирается: начать новый подмассив или продолжить текущий
- `maxSum` отслеживает глобальный максимум

**Математическая формулировка:**
```
currentSum[i] = max(nums[i], currentSum[i-1] + nums[i])
maxSum = max(maxSum, currentSum[i])
```

**Сложность:** O(n) - один проход по массиву

## Структура проекта

```
sem9/
├── Makefile              # Файл для сборки проекта
├── main.cpp              # Главная программа с тестированием
├── brute_force.h         # Заголовочный файл для перебора
├── brute_force.cpp       # Реализация полного перебора
├── optimal.h             # Заголовочный файл для алгоритма Кадане
└── optimal.cpp           # Реализация алгоритма Кадане
```

### Описание файлов

- **Makefile** - содержит правила для компиляции проекта
- **main.cpp** - тестирует оба алгоритма на различных размерах данных
- **brute_force.h/cpp** - реализация метода полного перебора
- **optimal.h/cpp** - реализация алгоритма Кадане

## Инструкция по сборке и запуску

### Сборка проекта
```bash
cd sem9
make
```

### Запуск программы
```bash
./main
```

### Очистка собранных файлов
```bash
make clean
```

## Результаты и анализ

### Экспериментальные данные
Программа тестирует оба алгоритма на массивах различных размеров:

| Размер | Перебор (мкс) | Кадане (мкс) | Ускорение |
|--------|---------------|--------------|-----------|
| 10     | 0             | 0            | -         |
| 50     | 6             | 0            | ∞         |
| 100    | 21            | 1            | 21×       |
| 500    | 468           | 5            | 94×       |
| 1000   | 1607          | 10           | 161×      |
| 5000   | 41326         | 55           | 751×      |

### Анализ производительности

#### Полный перебор
- **Теоретическая сложность:** O(n²)
- **Практическое поведение:** Квадратичный рост времени выполнения
- **Предел применимости:** ~10000 элементов (время выполнения > 1 секунда)

#### Алгоритм Кадане
- **Теоретическая сложность:** O(n)
- **Практическое поведение:** Линейный рост времени выполнения
- **Масштабируемость:** Эффективно работает с массивами до миллионов элементов

### Практический предел перебора
На основе экспериментальных данных можно определить:
- **1000 элементов:** ~1.6 мс - приемлемо для интерактивных приложений
- **5000 элементов:** ~41 мс - заметная задержка
- **10000 элементов:** ~165 мс (прогноз) - значительная задержка
- **20000 элементов:** ~660 мс (прогноз) - неприемлемо для реального времени

## Выводы

### 1. Сравнение алгоритмов

| Параметр | Полный перебор | Алгоритм Кадане |
|----------|----------------|-----------------|
| Сложность | O(n²) | O(n) |
| Простота реализации | Высокая | Средняя |
| Производительность | Низкая | Высокая |
| Память | O(1) | O(1) |
| Практический предел | ~10000 | Миллионы |

### 2. Обоснование выбора оптимального алгоритма

**Алгоритм Кадане является оптимальным решением** по следующим причинам:

1. **Линейная сложность** против квадратичной у перебора
2. **Константное использование памяти** - O(1) дополнительной памяти
3. **Высокая производительность** на больших объемах данных
4. **Простота реализации** после понимания принципа работы

### 3. Рекомендации по применению

- **Для малых массивов (n < 100):** Можно использовать любой алгоритм
- **Для средних массивов (100 < n < 1000):** Рекомендуется алгоритм Кадане
- **Для больших массивов (n > 1000):** Только алгоритм Кадане
- **Для образовательных целей:** Изучение обоих методов полезно для понимания разницы в сложности

### 4. Теоретическая значимость

Задача поиска максимального подмассива является классической проблемой компьютерных наук и демонстрирует:
- Важность выбора правильного алгоритма
- Разницу между наивными и оптимальными решениями
- Принципы динамического программирования
- Анализ вычислительной сложности на практике

Данная лабораторная работа наглядно показывает, как теоретическая оценка сложности соответствует практическим результатам и почему выбор алгоритма критически важен для производительности программ.
