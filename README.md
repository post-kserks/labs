# Лабораторная работа №11. Часть 3: Решение систем линейных уравнений

## Описание проекта

В данной лабораторной работе реализованы три различных метода решения систем линейных уравнений:

1. **Метод исключения Гаусса** - прямой метод решения СЛАУ
2. **Метод LU-разложения** - метод декомпозиции матрицы
3. **Метод обращения матрицы** - решение через нахождение обратной матрицы

Все методы применены к решению следующей системы уравнений:

```
x₁ + x₂ + x₃ = 2
2x₁ + x₂ + x₃ = 3
x₁ - x₂ + 3x₃ = 8
```

## Теоретическая основа

### Основные понятия

**Система линейных алгебраических уравнений (СЛАУ)** - это система вида:

```
A × x = b
```

где:
- `A` - матрица коэффициентов размера n×n
- `x` - вектор неизвестных размера n×1
- `b` - вектор правых частей размера n×1

Для нашей системы:

```cpp
// Матрица коэффициентов A
Matrix A(3, 3);
A.data = {
    {1.0, 1.0, 1.0},   // коэффициенты первого уравнения
    {2.0, 1.0, 1.0},   // коэффициенты второго уравнения
    {1.0, -1.0, 3.0}   // коэффициенты третьего уравнения
};

// Вектор правых частей b
std::vector<double> b = {2.0, 3.0, 8.0};
```

### Метод исключения Гаусса

**Метод Гаусса** - это прямой метод решения СЛАУ, который преобразует расширенную матрицу системы к ступенчатому виду путем последовательного исключения переменных.

#### Алгоритм метода Гаусса:

1. **Прямой ход (приведение к треугольному виду):**
   - На каждом шаге выбирается главный элемент (pivot)
   - Исключаются переменные в нижележащих уравнениях
   - Повторяется для всех столбцов

2. **Обратный ход (нахождение решения):**
   - Начиная с последнего уравнения, выражаются переменные
   - Подставляются найденные значения в предыдущие уравнения

#### Реализация в коде:

```cpp
std::vector<double> gaussElimination(AugmentedMatrix aug) {
    int n = aug.A.rows;

    // Прямой ход метода Гаусса
    for (int i = 0; i < n; ++i) {
        // Выбор главного элемента (частичный выбор)
        int maxRow = i;
        for (int k = i + 1; k < n; ++k) {
            if (std::abs(aug.A.data[k][i]) > std::abs(aug.A.data[maxRow][i])) {
                maxRow = k;
            }
        }

        // Перестановка строк
        if (maxRow != i) {
            std::swap(aug.A.data[i], aug.A.data[maxRow]);
            std::swap(aug.b[i], aug.b[maxRow]);
        }

        // Проверка на вырожденность
        if (std::abs(aug.A.data[i][i]) < 1e-10) {
            throw std::runtime_error("Матрица вырождена!");
        }

        // Исключение переменных
        for (int k = i + 1; k < n; ++k) {
            double factor = aug.A.data[k][i] / aug.A.data[i][i];
            for (int j = i; j < n; ++j) {
                aug.A.data[k][j] -= factor * aug.A.data[i][j];
            }
            aug.b[k] -= factor * aug.b[i];
        }
    }

    // Обратный ход
    std::vector<double> x(n);
    for (int i = n - 1; i >= 0; --i) {
        x[i] = aug.b[i];
        for (int j = i + 1; j < n; ++j) {
            x[i] -= aug.A.data[i][j] * x[j];
        }
        x[i] /= aug.A.data[i][i];
    }

    return x;
}
```

**Преимущества метода Гаусса:**
- Простота реализации
- Высокая точность для большинства задач
- Возможность выявления вырожденных матриц

### Метод LU-разложения

**LU-разложение** - это метод декомпозиции матрицы, при котором исходная матрица `A` представляется в виде произведения двух матриц:

```
A = L × U
```

где:
- `L` - нижняя треугольная матрица (Lower triangular)
- `U` - верхняя треугольная матрица (Upper triangular)

#### Алгоритм LU-разложения:

1. **Разложение матрицы A:**
   - Построение матриц L и U одновременно
   - L имеет единицы на главной диагонали
   - U получается в процессе разложения

2. **Решение системы:**
   - Решается система `L × y = b` (прямая подстановка)
   - Решается система `U × x = y` (обратная подстановка)

#### Реализация в коде:

```cpp
// LU-разложение матрицы A = L * U
void luDecompose(const Matrix& A, Matrix& L, Matrix& U) {
    int n = A.rows;

    for (int i = 0; i < n; ++i) {
        // Верхняя треугольная матрица U
        for (int k = i; k < n; ++k) {
            double sum = 0.0;
            for (int j = 0; j < i; ++j) {
                sum += L.data[i][j] * U.data[j][k];
            }
            U.data[i][k] = A.data[i][k] - sum;
        }

        // Нижняя треугольная матрица L
        for (int k = i; k < n; ++k) {
            if (i == k) {
                L.data[i][i] = 1.0;
            } else {
                double sum = 0.0;
                for (int j = 0; j < i; ++j) {
                    sum += L.data[k][j] * U.data[j][i];
                }
                L.data[k][i] = (A.data[k][i] - sum) / U.data[i][i];
            }
        }
    }
}

// Прямая подстановка для решения L * y = b
std::vector<double> forwardSubstitution(const Matrix& L, const std::vector<double>& b) {
    int n = L.rows;
    std::vector<double> y(n);

    for (int i = 0; i < n; ++i) {
        y[i] = b[i];
        for (int j = 0; j < i; ++j) {
            y[i] -= L.data[i][j] * y[j];
        }
        // L.data[i][i] всегда равна 1, так что делить не нужно
    }

    return y;
}

// Обратная подстановка для решения U * x = y
std::vector<double> backwardSubstitution(const Matrix& U, const std::vector<double>& y) {
    int n = U.rows;
    std::vector<double> x(n);

    for (int i = n - 1; i >= 0; --i) {
        x[i] = y[i];
        for (int j = i + 1; j < n; ++j) {
            x[i] -= U.data[i][j] * x[j];
        }
        x[i] /= U.data[i][i];
    }

    return x;
}

// Метод LU-разложения
std::vector<double> luDecomposition(const Matrix& A, const std::vector<double>& b) {
    int n = A.rows;
    Matrix L(n, n);
    Matrix U(n, n);

    // LU-разложение
    luDecompose(A, L, U);

    // Решение L * y = b
    std::vector<double> y = forwardSubstitution(L, b);

    // Решение U * x = y
    std::vector<double> x = backwardSubstitution(U, y);

    return x;
}
```

**Преимущества LU-разложения:**
- Разложение можно использовать повторно для разных правых частей
- Метод устойчив для хорошо обусловленных матриц
- Эффективен при решении нескольких систем с одной матрицей

### Метод обращения матрицы

**Метод обращения матрицы** решает систему уравнений по формуле:

```
x = A⁻¹ × b
```

где `A⁻¹` - обратная матрица к матрице `A`.

#### Алгоритм нахождения обратной матрицы (метод Гаусса-Жордана):

1. **Создание расширенной матрицы:** `[A | I]`, где `I` - единичная матрица
2. **Прямой ход:** Приведение левой части к единичной матрице
3. **Обратная матрица:** Правая часть становится обратной матрицей

#### Реализация в коде:

```cpp
// Нахождение обратной матрицы методом Гаусса-Жордана
Matrix matrixInverse(const Matrix& A) {
    int n = A.rows;
    Matrix augmented(n, 2 * n);

    // Создание расширенной матрицы [A | I]
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            augmented.data[i][j] = A.data[i][j];
            augmented.data[i][j + n] = (i == j) ? 1.0 : 0.0;
        }
    }

    // Прямой ход метода Гаусса-Жордана
    for (int i = 0; i < n; ++i) {
        // Выбор главного элемента
        int maxRow = i;
        for (int k = i + 1; k < n; ++k) {
            if (std::abs(augmented.data[k][i]) > std::abs(augmented.data[maxRow][i])) {
                maxRow = k;
            }
        }

        // Перестановка строк
        if (maxRow != i) {
            std::swap(augmented.data[i], augmented.data[maxRow]);
        }

        // Нормировка строки
        double pivot = augmented.data[i][i];
        for (int j = 0; j < 2 * n; ++j) {
            augmented.data[i][j] /= pivot;
        }

        // Исключение элементов в столбце
        for (int k = 0; k < n; ++k) {
            if (k != i) {
                double factor = augmented.data[k][i];
                for (int j = 0; j < 2 * n; ++j) {
                    augmented.data[k][j] -= factor * augmented.data[i][j];
                }
            }
        }
    }

    // Извлечение обратной матрицы
    Matrix inverse(n, n);
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            inverse.data[i][j] = augmented.data[i][j + n];
        }
    }

    return inverse;
}

// Метод обращения матрицы
std::vector<double> matrixInverseMethod(const Matrix& A, const std::vector<double>& b) {
    // Находим обратную матрицу
    Matrix A_inv = matrixInverse(A);

    // Умножаем на вектор свободных членов: x = A^(-1) * b
    return matrixVectorMultiply(A_inv, b);
}
```

**Недостатки метода обращения матрицы:**
- Вычислительно дорогой (O(n³) для обращения + O(n²) для умножения)
- Может быть численно неустойчивым
- Не рекомендуется для больших систем

## Структура проекта

```
lab11p3/
├── Makefile          # Скрипт сборки проекта
├── matrix.h          # Заголовочный файл с определениями
├── main.cpp          # Основная программа
├── methods.cpp       # Реализация численных методов
└── task2.md          # Ответ на задание 2б
```

## Сборка и запуск

```bash
# Сборка проекта
make

# Запуск программы
./lab11p3

# Очистка объектных файлов
make clean
```

## Результаты решения

Все три метода дали одинаковый результат:

```
Решение: x₁ = 1, x₂ = -1, x₃ = 2

Проверка подстановкой:
Уравнение 1: 1 + (-1) + 2 = 2 ✓
Уравнение 2: 2×1 + (-1) + 2 = 3 ✓
Уравнение 3: 1 - (-1) + 3×2 = 8 ✓
```

## Сравнение методов

| Метод | Преимущества | Недостатки | Сложность |
|-------|-------------|------------|-----------|
| Гаусс | Простота, точность | Неэффективен для повторных решений | O(n³) |
| LU-разложение | Повторное использование разложения | Требует хранения двух матриц | O(n³) |
| Обращение матрицы | Простая формула | Неэффективен, нестабилен | O(n³) |

## Классификация метода LU-разложения

Метод LU-разложения можно классифицировать как **метод декомпозиции** (разложения) с точки зрения методов разработки алгоритмов.

**Декомпозиция** - это подход, при котором сложная задача разбивается на несколько более простых подзадач. В LU-разложении:

1. **Сложная задача:** Решение системы Ax = b
2. **Разбиение:**
   - Разложение A = L×U (однократная операция)
   - Решение Ly = b (простая подстановка)
   - Решение Ux = y (простая подстановка)

Такой подход позволяет эффективно решать системы с одинаковой матрицей коэффициентов и разными правыми частями.

## Заключение

В лабораторной работе успешно реализованы три различных подхода к решению систем линейных уравнений. Все методы дали корректный результат, что подтверждает правильность их реализации. Метод Гаусса оказался наиболее универсальным, в то время как LU-разложение предпочтительно при необходимости многократного решения систем с одной матрицей.