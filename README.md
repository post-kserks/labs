# Лабораторная работа №4 часть 2: Численное интегрирование

## Содержание
1. [Цель работы](#цель-работы)
2. [Постановка задачи](#постановка-задачи)
3. [Теоретические основы](#теоретические-основы)
4. [Анализ задачи](#анализ-задачи)
5. [Структура проекта](#структура-проекта)
6. [Инструкция по сборке и запуску](#инструкция-по-сборке-и-запуску)
7. [Реализация методов](#реализация-методов)
8. [Анализ результатов](#анализ-результатов)
9. [Выводы](#выводы)

## Цель работы

**Основная цель**: Освоить методы численного интегрирования (метод прямоугольников, трапеций, Симпсона) и провести сравнительный анализ их точности и производительности.

**Конкретные задачи**:
- Реализовать алгоритмы численного интегрирования на C++
- Вычислить интеграл функции f(x) = √(4 - x²) на отрезке [0, 2]
- Провести вычисления для различных значений n (10, 1000, 100000, 10000000)
- Сравнить результаты методов между собой и с аналитическим решением
- Определить вычислительную сложность алгоритмов
- Сделать выводы о точности методов и скорости их сходимости

## Постановка задачи

Необходимо вычислить определенный интеграл:
```
∫₀² √(4 - x²) dx
```

**Аналитическое решение**: Данный интеграл представляет собой площадь четверти круга радиусом 2. Аналитическое решение равно π ≈ 3.141592653589793.

**Численные методы**:
- Метод левых прямоугольников
- Метод правых прямоугольников
- Метод средних прямоугольников
- Метод трапеций
- Метод Симпсона (парабол)

## Теоретические основы

### Метод прямоугольников

**Идея**: Замена площади под кривой на сумму площадей прямоугольников.

**Формула левых прямоугольников**:
```cpp
double left_rectangle_method(double a, double b, int n) {
    double h = (b - a) / n;
    double sum = 0.0;
    for (int i = 0; i < n; i++) {
        double x = a + i * h;
        sum += semi_circle_function(x);
    }
    return sum * h;
}
```

**Погрешность**: O(1/n)

### Метод трапеций

**Идея**: Замена площади под кривой на сумму площадей трапеций.

**Формула**:
```cpp
double trapezoidal_method(double a, double b, int n) {
    double h = (b - a) / n;
    double sum = (semi_circle_function(a) + semi_circle_function(b)) / 2.0;
    for (int i = 1; i < n; i++) {
        double x = a + i * h;
        sum += semi_circle_function(x);
    }
    return sum * h;
}
```

**Погрешность**: O(1/n²)

### Метод Симпсона

**Идея**: Замена подынтегральной функции на квадратичные параболы.

**Формула**:
```cpp
double simpson_method(double a, double b, int n) {
    if (n % 2 != 0) n++; // Убедимся, что n четное
    double h = (b - a) / n;
    double sum = semi_circle_function(a) + semi_circle_function(b);

    // Нечетные точки (умножаем на 4)
    for (int i = 1; i < n; i += 2) {
        double x = a + i * h;
        sum += 4 * semi_circle_function(x);
    }

    // Четные точки (умножаем на 2)
    for (int i = 2; i < n; i += 2) {
        double x = a + i * h;
        sum += 2 * semi_circle_function(x);
    }

    return sum * h / 3.0;
}
```

**Погрешность**: O(1/n⁴)

## Анализ задачи

### Выбор функции и пределов интегрирования

**Функция**: f(x) = √(4 - x²)

**Почему именно эта функция?**
- Это уравнение верхней полуокружности радиусом 2
- Аналитическое решение известно и равно π
- Функция непрерывна на отрезке [0, 2]
- Имеет производные всех порядков, что важно для оценки погрешности

**Пределы интегрирования [0, 2]**:
- При x = 0: f(0) = √4 = 2 (максимальное значение)
- При x = 2: f(2) = √0 = 0 (функция обращается в ноль)
- На этом отрезке функция монотонно убывает

```cpp
const double A = 0.0;          // Нижний предел интегрирования
const double B = 2.0;          // Верхний предел интегрирования
const double ANALYTICAL_RESULT = M_PI;  // Аналитическое решение
```

### Выбор значений n

**Значения n**: 10, 1000, 100000, 10000000

**Почему именно эти значения?**
- **n = 10**: Малое количество разбиений, позволяет увидеть грубые приближения
- **n = 1000**: Среднее количество, демонстрирует улучшение точности
- **n = 100000**: Большое количество, показывает асимптотическое поведение
- **n = 10000000**: Очень большое количество, демонстрирует предельную точность и производительность

```cpp
const std::vector<int> TEST_VALUES_N = {10, 1000, 100000, 10000000};
```

### Математическая корректность

**Проверка функции в граничных точках**:
```cpp
double f0 = semi_circle_function(0.0);  // √4 = 2
double f2 = semi_circle_function(2.0);  // √0 = 0
double f1 = semi_circle_function(1.0);  // √3 ≈ 1.732
```

**Геометрическая интерпретация**: Интеграл действительно представляет площадь четверти круга радиусом 2, что подтверждается аналитическим решением π.

## Структура проекта

```
numerical_integration/
├── src/
│   ├── main.cpp                 # Основная программа
│   ├── integration_methods.cpp  # Реализация методов интегрирования
│   ├── integration_methods.hpp  # Заголовочный файл методов
│   ├── math_functions.cpp       # Математические функции
│   ├── math_functions.hpp       # Заголовочный файл функций
│   └── time_measurement.cpp     # Измерение времени выполнения
├── include/
│   └── common.hpp              # Общие константы и определения
├── tests/
│   └── test_integration.cpp    # Юнит-тесты
└── Makefile                    # Файл сборки
```

## Инструкция по сборке и запуску

### Сборка проекта:
```bash
make
```

### Запуск основной программы:
```bash
make run
```
или
```bash
./numerical_integration
```

### Запуск тестов:
```bash
make test
```

### Очистка:
```bash
make clean
```

## Реализация методов

### Основная программа
```cpp
int main() {
    print_header();

    for (int n : TEST_VALUES_N) {
        // Для каждого метода: измеряем время и вычисляем интеграл
        double time_left = measure_execution_time(left_rectangle_method, A, B, n);
        double result_left = left_rectangle_method(A, B, n);
        print_result(n, "Левые прям.", result_left, time_left);
        // ... аналогично для других методов
    }

    print_complexity_analysis();
    return 0;
}
```

### Измерение времени выполнения
```cpp
double measure_execution_time(double (*method)(double, double, int),
                             double a, double b, int n, int iterations) {
    auto start = std::chrono::high_resolution_clock::now();

    for (int i = 0; i < iterations; i++) {
        method(a, b, n);
    }

    auto end = std::chrono::high_resolution_clock::now();
    std::chrono::duration<double> duration = end - start;

    return duration.count() / iterations;
}
```

## Анализ результатов

### Точность методов

**Метод Симпсона** демонстрирует наивысшую точность благодаря использованию квадратичных аппроксимаций. При n = 10000000 погрешность составляет порядка 10⁻¹⁴.

**Метод средних прямоугольников** точнее методов левых/правых прямоугольников, так как использует значение функции в средней точке отрезка.

**Методы левых и правых прямоугольников** имеют наименьшую точность из-за линейной аппроксимации.

### Вычислительная сложность

**Все методы имеют сложность O(n)**, так как количество операций прямо пропорционально количеству разбиений:

```cpp
// Пример для метода левых прямоугольников:
for (int i = 0; i < n; i++) {  // O(n) операций
    double x = a + i * h;
    sum += semi_circle_function(x);
}
```

### Время выполнения

Время выполнения растет линейно с увеличением n, что подтверждает сложность O(n). При n = 10000000 время выполнения составляет доли секунды для всех методов.

### Сходимость методов

**Быстрая сходимость**: Метод Симпсона сходится быстрее всех благодаря погрешности O(1/n⁴).

**Медленная сходимость**: Методы прямоугольников сходятся медленнее из-за погрешности O(1/n).

## Выводы

1. **Точность методов**:
   - Метод Симпсона - самый точный (погрешность O(1/n⁴))
   - Метод трапеций - средняя точность (погрешность O(1/n²))
   - Методы прямоугольников - наименьшая точность (погрешность O(1/n))

2. **Производительность**:
   - Все методы имеют линейную сложность O(n)
   - Время выполнения пропорционально количеству разбиений
   - Метод Симпсона требует больше вычислений на одну итерацию, но дает лучшую точность

3. **Практические рекомендации**:
   - Для высокой точности использовать метод Симпсона
   - Для быстрых приближенных вычислений подходят метод трапеций или средних прямоугольников
   - Методы левых/правых прямоугольников использовать только для грубых оценок

4. **Математическая корректность**:
   - Все методы дают результаты, близкие к аналитическому решению π
   - С увеличением n точность всех методов возрастает
   - Реализация корректна с математической точки зрения

\
