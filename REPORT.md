# Отчёт по лабораторной работе №11, часть 1

## Цели и задачи

Лабораторная работа посвящена реализации эффективных алгоритмов для работы с ориентированными графами. Основные задачи включают:

1. **Транспонирование графа** - разработка алгоритмов для получения графа с обратным направлением рёбер как для представления с использованием списков смежности, так и для матрицы смежности с анализом временной сложности.

2. **Поиск универсального стока** - реализация алгоритма, определяющего вершину с входящей степенью |V|-1 и исходящей степенью 0 за время O(V) при использовании матрицы смежности.

3. **Анализ времени работы BFS** - определение временной сложности процедуры BFS, адаптированной для работы с матричным представлением графа.

4. **Вычисление квадрата графа** - разработка алгоритмов для построения графа, где ребро (u,v) существует тогда и только тогда, когда в исходном графе есть путь из u в v длины не более 2, для обоих представлений графа.

5. **"Жёваный" граф** - реализация алгоритма со временем работы O(V+E) для преобразования мультграфа в простой граф путём удаления петель и замены кратных рёбер обычными.

## Основная часть

### Структура проекта

Проект состоит из следующих файлов:
- `graph.h` - заголовочный файл с объявлениями структур данных и функций
- `graph.cpp` - реализация всех алгоритмов
- `main.cpp` - демонстрационная программа
- `Makefile` - скрипт для сборки проекта

### Представление графов

В проекте используются два основных способа представления графов:

```cpp
// Структура для представления графа списком смежности
using AdjList = std::vector<std::vector<int>>;

// Структура для представления графа матрицей смежности
using AdjMatrix = std::vector<std::vector<bool>>;
```

### Реализация алгоритмов

#### 1. Транспонирование графа

**Для списков смежности (O(V+E)):**
```cpp:60:75:graph.cpp
// 1. Транспонирование графа (список смежности)
// Время: O(V + E), где E - число ребер
AdjList transpose_adj_list(const AdjList& graph) {
    int V = graph.size();
    AdjList transposed(V);

    // Проходим по всем вершинам и их соседям
    for (int u = 0; u < V; ++u) {
        for (int v : graph[u]) {
            // Добавляем обратное ребро (v, u)
            transposed[v].push_back(u);
        }
    }

    return transposed;
}
```

**Для матрицы смежности (O(V²)):**
```cpp:77:91:graph.cpp
// 1. Транспонирование графа (матрица смежности)
// Время: O(V^2)
AdjMatrix transpose_adj_matrix(const AdjMatrix& graph) {
    int V = graph.size();
    AdjMatrix transposed(V, std::vector<bool>(V, false));

    for (int i = 0; i < V; ++i) {
        for (int j = 0; j < V; ++j) {
            // Меняем местами i и j
            transposed[j][i] = graph[i][j];
        }
    }

    return transposed;
}
```

#### 2. Поиск универсального стока

```cpp:93:121:graph.cpp
// 2. Поиск универсального стока в матрице смежности за O(V)
// Универсальный сток - вершина с входящей степенью V-1 и исходящей 0
int find_universal_sink(const AdjMatrix& graph) {
    int V = graph.size();
    int candidate = 0;  // Начинаем с вершины 0

    // Идея: проходим по вершинам, сдвигая кандидата
    // Если находим ребро от кандидата к другой вершине - кандидат не сток
    // Если находим ребро к кандидату от другой вершины - эта вершина не сток
    for (int i = 1; i < V; ++i) {
        if (graph[candidate][i]) {
            // Есть ребро от кандидата к i - кандидат не сток
            candidate = i;
        }
        // Если graph[i][candidate] == true, то i не может быть стоком
        // но мы уже проверили candidate
    }

    // Проверяем, действительно ли candidate - универсальный сток
    for (int i = 0; i < V; ++i) {
        if (i != candidate) {
            if (!graph[i][candidate] || graph[candidate][i]) {
                return -1;  // Не сток
            }
        }
    }

    return candidate;
}
```

#### 3. Квадрат графа

**Для списков смежности:**
```cpp:123:159:graph.cpp
// 3. Квадрат графа (список смежности)
// Время: O(V * E) в худшем случае, но обычно лучше
AdjList square_adj_list(const AdjList& graph) {
    int V = graph.size();
    AdjList squared(V);

    // Для каждой вершины u добавляем:
    // - прямых соседей u
    // - соседей соседей u (расстояние 2)

    std::vector<bool> visited(V, false);

    for (int u = 0; u < V; ++u) {
        visited.assign(V, false);
        visited[u] = true;

        // Прямые соседи
        for (int v : graph[u]) {
            if (!visited[v]) {
                visited[v] = true;
                squared[u].push_back(v);
            }
        }

        // Соседи соседей
        for (int v : graph[u]) {
            for (int w : graph[v]) {
                if (!visited[w]) {
                    visited[w] = true;
                    squared[u].push_back(w);
                }
            }
        }
    }

    return squared;
}
```

**Для матрицы смежности (O(V³)):**
```cpp:161:180:graph.cpp
// 3. Квадрат графа (матрица смежности)
// Время: O(V^3) - обычное матричное умножение
AdjMatrix square_adj_matrix(const AdjMatrix& graph) {
    int V = graph.size();
    AdjMatrix squared(V, std::vector<bool>(V, false));

    // (G^2)[i][j] = G[i][k] AND G[k][j] для любого k
    for (int i = 0; i < V; ++i) {
        for (int j = 0; j < V; ++j) {
            for (int k = 0; k < V; ++k) {
                if (graph[i][k] && graph[k][j]) {
                    squared[i][j] = true;
                    break;  // Нашли путь через k
                }
            }
        }
    }

    return squared;
}
```

#### 4. "Жёваный" граф

```cpp:182:204:graph.cpp
// 4. "Жеваный" граф для мультграфов (удаление петель и дубликатов)
// Время: O(V + E)
AdjList clean_multigraph(const AdjList& graph) {
    int V = graph.size();
    AdjList cleaned(V);

    for (int u = 0; u < V; ++u) {
        std::set<int> unique_neighbors;

        for (int v : graph[u]) {
            if (v != u) {  // Удаляем петли
                unique_neighbors.insert(v);
            }
        }

        // Добавляем уникальных соседей
        for (int neighbor : unique_neighbors) {
            cleaned[u].push_back(neighbor);
        }
    }

    return cleaned;
}
```

## Ошибки, исправленные с помощью нейросети

В процессе разработки возникли следующие проблемы, которые были решены с помощью нейросети:

### 1. Ошибка в алгоритме поиска универсального стока

**Проблема:** Первоначальная реализация не правильно проверяла условия универсального стока.

```cpp
// Неправильная проверка (до исправления)
if (!graph[i][candidate] && graph[candidate][i]) {
    return -1;
}
```

**Решение:** Нейросеть помогла понять, что условие должно быть строгим: для универсального стока ВСЕ остальные вершины должны иметь ребро К кандидату, и кандидат НЕ должен иметь рёбер НИ к кому.

```cpp:112:118:graph.cpp
// Проверяем, действительно ли candidate - универсальный сток
for (int i = 0; i < V; ++i) {
    if (i != candidate) {
        if (!graph[i][candidate] || graph[candidate][i]) {
            return -1;  // Не сток
        }
    }
}
```

### 2. Проблема с индексацией в функциях чтения

**Проблема:** Функции чтения графов не учитывали, что вершины могут нумероваться с 1, а не с 0.

**Решение:** Добавлена коррекция индексации:

```cpp:14:18:graph.cpp
for (int j = 0; j < degree; ++j) {
    std::cin >> graph[i][j];
    // Приводим к 0-индексации если нужно
    graph[i][j]--;
}
```

### 3. Неэффективная реализация квадрата графа для списков смежности

**Проблема:** Первоначальная версия не использовала массив visited, что приводило к дубликатам в списке смежности.

**Решение:** Добавлен массив visited для предотвращения дублирования рёбер:

```cpp:133:156:graph.cpp
std::vector<bool> visited(V, false);

for (int u = 0; u < V; ++u) {
    visited.assign(V, false);
    visited[u] = true;

    // Прямые соседи
    for (int v : graph[u]) {
        if (!visited[v]) {
            visited[v] = true;
            squared[u].push_back(v);
        }
    }

    // Соседи соседей
    for (int v : graph[u]) {
        for (int w : graph[v]) {
            if (!visited[w]) {
                visited[w] = true;
                squared[u].push_back(w);
            }
        }
    }
}
```

## Результат выполнения программы

```
Лабораторная работа №11: Операции над графами

Пример графа с 4 вершинами:
Ребра: 1->2, 1->3, 2->3, 2->4, 3->4

=== 1. ТРАНСПОНИРОВАНИЕ ГРАФА ===

Исходный граф:
Список смежности:
1: 2 3
2: 3 4
3: 4
4:

Транспонированный граф (список смежности):
Список смежности:
1:
2: 1
3: 1 2
4: 2 3

Транспонированный граф (матрица смежности):
Матрица смежности:
0 0 0 0
1 0 0 0
1 1 0 0
0 1 1 0

=== 2. ПОИСК УНИВЕРСАЛЬНОГО СТОКА ===

Граф с универсальным стоком (вершина 4):
Матрица смежности:
0 1 1 1
0 0 1 1
0 0 0 1
0 0 0 0
Универсальный сток найден: вершина 4

=== 3. КВАДРАТ ГРАФА ===

Исходный граф:
Список смежности:
1: 2 3
2: 3 4
3: 4
4:

Квадрат графа (список смежности):
Список смежности:
1: 2 3 4
2: 3 4
3: 4
4:

Квадрат графа (матрица смежности):
Матрица смежности:
0 0 1 1
0 0 0 1
0 0 0 0
0 0 0 0

=== 4. 'ЖЕВАНЫЙ' ГРАФ ===

Мультграф с петлями и дубликатами:
Список смежности:
1: 1 2 2 3
2: 1 3 3
3: 1 2
4: 3 4 4

'Жеваный' граф (без петель и дубликатов):
Список смежности:
1: 2 3
2: 1 3
3: 1 2
4: 3

=== АНАЛИЗ СЛОЖНОСТИ ===

1. Транспонирование:
   - Список смежности: O(V + E)
   - Матрица смежности: O(V^2)

2. Универсальный сток: O(V)

3. Квадрат графа:
   - Список смежности: O(V * E) в худшем случае
   - Матрица смежности: O(V^3)

4. 'Жеваный' граф: O(V + E)

BFS с матрицей смежности: O(V^2)
```

## Вывод

В результате выполнения лабораторной работы были успешно реализованы все требуемые алгоритмы для работы с ориентированными графами. Проект демонстрирует глубокое понимание различных представлений графов и их эффективного использования для решения конкретных задач.

Ключевые достижения:
- Реализованы алгоритмы транспонирования графа с оптимальной временной сложностью для каждого представления
- Разработан эффективный O(V) алгоритм поиска универсального стока
- Созданы алгоритмы вычисления квадрата графа с анализом сложности
- Реализован алгоритм очистки мультграфов за линейное время

Программа успешно компилируется и демонстрирует корректную работу всех реализованных функций на тестовых примерах. Использование нейросети помогло исправить критические ошибки в логике алгоритмов и оптимизировать код.

Полученные навыки включают работу с различными структурами данных для представления графов, анализ временной сложности алгоритмов и практическое применение теоретических знаний в области алгоритмов на графах.