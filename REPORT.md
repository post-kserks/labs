# ОТЧЕТ ПО СЕМИНАРУ 16

**Дисциплина:** Алгоритмы и структуры данных
**Тема:** Реализация алгоритмов поиска медианы, пересечения множеств и экстремальных значений
**Вариант:** 1, 3, 4
**Студент:** [Ваше ФИО]
**Группа:** [Ваша группа]
**Дата выполнения:** Декабрь 2024
**Преподаватель:** [ФИО преподавателя]

---

## СОДЕРЖАНИЕ

1. [ВВЕДЕНИЕ](#введение)
   - 1.1. [Цели и задачи семинара](#цели-и-задачи-семинара)
   - 1.2. [Формулировка заданий](#формулировка-заданий)

2. [ТЕОРЕТИЧЕСКАЯ ЧАСТЬ](#теоретическая-часть)
   - 2.1. [Задача 1: Поиск медианы](#задача-1-поиск-медианы)
   - 2.2. [Задача 3: Пересечение множеств](#задача-3-пересечение-множеств)
   - 2.3. [Задача 4: Поиск экстремальных значений](#задача-4-поиск-экстремальных-значений)

3. [ПРАКТИЧЕСКАЯ РЕАЛИЗАЦИЯ](#практическая-реализация)
   - 3.1. [Архитектура программы](#архитектура-программы)
   - 3.2. [Используемые технологии](#используемые-технологии)
   - 3.3. [Реализация алгоритмов](#реализация-алгоритмов)

4. [РЕЗУЛЬТАТЫ ВЫПОЛНЕНИЯ ПРОГРАММЫ](#результаты-выполнения-программы)
   - 4.1. [Тестирование алгоритмов](#тестирование-алгоритмов)
   - 4.2. [Анализ производительности](#анализ-производительности)
   - 4.3. [Корректность результатов](#корректность-результатов)

5. [ПРОБЛЕМЫ И ИХ РЕШЕНИЕ](#проблемы-и-их-решение)
   - 5.1. [Технические трудности](#технические-трудности)
   - 5.2. [Алгоритмические сложности](#алгоритмические-сложности)
   - 5.3. [Помощь нейросети в решении проблем](#помощь-нейросети-в-решении-проблем)

6. [ВЫВОДЫ](#выводы)
   - 6.1. [Достигнутые цели](#достигнутые-цели)
   - 6.2. [Полученные навыки](#полученные-навыки)
   - 6.3. [Рекомендации](#рекомендации)

7. [ПРИЛОЖЕНИЯ](#приложения)
   - 7.1. [Исходный код программы](#исходный-код-программы)
   - 7.2. [Результаты тестирования](#результаты-тестирования)

---

## 1. ВВЕДЕНИЕ

### 1.1. Цели и задачи семинара

Основной целью семинара 16 является углубленное изучение фундаментальных алгоритмов обработки данных и закрепление навыков анализа асимптотической сложности алгоритмов. В рамках данной работы были поставлены следующие задачи:

1. **Изучение теоретических основ алгоритмов** - понимание принципов работы различных подходов к решению типичных задач обработки данных.

2. **Практическая реализация алгоритмов** - разработка корректных и эффективных программных решений на языке C++.

3. **Анализ эффективности алгоритмов** - сравнение различных подходов к решению одной задачи по времени выполнения и асимптотической сложности.

4. **Применение современных инструментов разработки** - использование систем сборки, контроля версий и документации.

5. **Развитие навыков отладки и оптимизации** - выявление и устранение ошибок, оптимизация производительности.

Семинар направлен на формирование глубокого понимания того, как выбор алгоритма влияет на эффективность решения задачи, и почему важно учитывать не только корректность, но и производительность решения.

### 1.2. Формулировка заданий

#### Задача 1: Поиск медианы с предварительной сортировкой
Разработать алгоритм для поиска медианы множества из n чисел с использованием предварительной сортировки и определить класс его эффективности.

**Определение медианы:** Медианой множества из n чисел называется его [n/2] элемент в порядке возрастания.

#### Задача 3: Пересечение множеств
Даны два множества A = {a₁, a₂, …, aₙ} и B = {b₁, b₂, …, bₘ}. Рассмотреть задачу поиска их пересечения C.

**а) Алгоритм грубой силы** - разработать и определить эффективность.
**б) Алгоритм с предварительной сортировкой** - разработать и определить эффективность.

#### Задача 4: Поиск экстремальных значений
Рассмотреть задачу поиска наибольшего и наименьшего элементов в массиве из n чисел.

**а) Алгоритм с предварительной сортировкой** - разработать и определить эффективность.
**б) Сравнение алгоритмов** - грубой силы, сортировки и декомпозиции.

---

## 2. ТЕОРЕТИЧЕСКАЯ ЧАСТЬ

### 2.1. Задача 1: Поиск медианы

#### Определение и свойства медианы

Медиана является важной статистической характеристикой набора данных, представляющей собой значение, разделяющее упорядоченное множество на две равные части. Для нечетного количества элементов медианой является средний элемент, для четного - обычно выбирается один из двух центральных элементов.

**Формальное определение:** Медианой множества из n чисел называется элемент с порядковым номером ⌈n/2⌉ в отсортированном по возрастанию массиве.

#### Алгоритм решения с предварительной сортировкой

**Алгоритм:**
1. Отсортировать входной массив по возрастанию
2. Вернуть элемент с индексом `n/2` (целочисленное деление)

**Асимптотическая сложность:**
- **Время:** O(n log n) - доминирует операция сортировки
- **Память:** O(1) дополнительной памяти (in-place сортировка)

#### Доказательство корректности

Пусть имеется отсортированный массив `arr[0..n-1]`. Элемент `arr[k]` является медианой, если выполняется условие:
- Количество элементов ≤ arr[k] равно k+1
- Количество элементов ≥ arr[k] равно n-k

Для k = n/2 (целочисленное деление):
- Левая часть: элементы arr[0] до arr[k-1] ≤ arr[k]
- Правая часть: элементы arr[k+1] до arr[n-1] ≥ arr[k]
- Таким образом, arr[k] делит массив на две примерно равные части

#### Сравнение с альтернативными подходами

| Метод | Сложность | Преимущества | Недостатки |
|-------|-----------|--------------|------------|
| Сортировка | O(n log n) | Простота, понятность | Не оптимально |
| QuickSelect | O(n) в среднем | Оптимальная сложность | Сложнее реализация |
| Heap-based | O(n log k) | Для потоковых данных | Ограниченное применение |

### 2.2. Задача 3: Пересечение множеств

#### Теоретические основы

Пересечением двух множеств A и B называется множество C = {x | x ∈ A ∧ x ∈ B}, содержащее все элементы, принадлежащие одновременно обоим множествам.

#### Алгоритм а): Метод грубой силы

**Алгоритм:**
```
intersection_brute_force(A, B):
    result = пустой массив
    для каждого элемента a из A:
        для каждого элемента b из B:
            если a == b:
                если a не содержится в result:
                    добавить a в result
    вернуть result
```

**Асимптотическая сложность:** O(n × m)
- n = |A|, m = |B|
- В худшем случае: каждый элемент A проверяется со всеми элементами B
- Дополнительные операции: O(min(n,m)) для проверки дубликатов

**Анализ:**
- **Временная сложность:** O(n×m) сравнений
- **Пространственная сложность:** O(min(n,m)) для хранения результата
- **Устойчивость к входным данным:** Работает одинаково на любых входах

#### Алгоритм б): Метод с предварительной сортировкой

**Алгоритм:**
```
intersection_sorted(A, B):
    сортировать A и B
    result = пустой массив
    i = 0, j = 0
    пока i < len(A) и j < len(B):
        если A[i] == B[j]:
            добавить A[i] в result (если не дубликат)
            i++, j++
        иначе если A[i] < B[j]:
            i++
        иначе:
            j++
    вернуть result
```

**Асимптотическая сложность:** O((n+m) × log max(n,m))
- **Сортировка:** O(n log n + m log m)
- **Проход с двумя указателями:** O(n + m)
- **Общая:** O((n+m) × log max(n,m))

**Доказательство корректности:**
Алгоритм использует классический подход двух указателей на отсортированных массивах. Инвариант: все элементы левее i в A и левее j в B уже обработаны. При равенстве элементов они принадлежат пересечению.

### 2.3. Задача 4: Поиск экстремальных значений

#### Постановка задачи

Найти минимальный и максимальный элементы в массиве из n чисел.

#### Алгоритм а): С предварительной сортировкой

**Алгоритм:**
```
find_minmax_sorted(arr):
    сортировать arr
    вернуть {arr[0], arr[arr.length-1]}
```

**Сложность:** O(n log n)

#### Алгоритм б): Метод грубой силы (линейный поиск)

**Алгоритм:**
```
find_minmax_brute_force(arr):
    min_val = +∞, max_val = -∞
    для каждого элемента x в arr:
        если x < min_val: min_val = x
        если x > max_val: max_val = x
    вернуть {min_val, max_val}
```

**Сложность:** O(n) - ровно 2×(n-1) сравнений

#### Алгоритм в): Турнирный метод (декомпозиция)

**Принцип:** Разделить массив на пары, найти локальные min/max в каждой паре, затем объединить результаты.

**Алгоритм:**
```
find_minmax_tournament(arr):
    создать массив candidates
    для i от 0 до n-1 с шагом 2:
        если есть пара arr[i], arr[i+1]:
            если arr[i] < arr[i+1]:
                добавить arr[i], arr[i+1] в candidates
            иначе:
                добавить arr[i+1], arr[i] в candidates
        иначе:
            добавить arr[i], arr[i] в candidates

    найти глобальный min среди первых элементов candidates
    найти глобальный max среди вторых элементов candidates
```

**Теоретическая сложность:** O(n) с константой ~1.5
**Практическая сложность:** O(n) с большим константным множителем

#### Сравнительный анализ

| Метод | Сложность | Сравнения | Преимущества | Недостатки |
|-------|-----------|-----------|--------------|------------|
| Сортировка | O(n log n) | O(n log n) | Простота | Неэффективно |
| Грубая сила | O(n) | 2(n-1) | Оптимально | - |
| Турнирный | O(n) | ~1.5n | Минимально сравнений | Overhead |

---

## 3. ПРАКТИЧЕСКАЯ РЕАЛИЗАЦИЯ

### 3.1. Архитектура программы

Программа реализована в соответствии с принципом разделения ответственности:

```
├── main.cpp           # Демонстрация работы алгоритмов
├── median.h/.cpp      # Задача 1
├── intersection.h/.cpp # Задача 3
├── minmax.h/.cpp      # Задача 4
├── Makefile           # Сборка проекта
└── README.md          # Документация
```

**Архитектурные решения:**
- **Процедурный стиль:** Выбран для простоты и понятности
- **Модульная структура:** Каждый алгоритм в отдельном модуле
- **Отсутствие ООП:** Фокус на алгоритмах, а не на архитектуре
- **Минимализм:** Только необходимый код без излишеств

### 3.2. Используемые технологии

- **Язык программирования:** C++17
- **Компилятор:** g++ (GCC) 11+
- **Система сборки:** GNU Make
- **Библиотеки:** STL (vector, algorithm, chrono)
- **Среда разработки:** Командная строка macOS

### 3.3. Реализация алгоритмов

#### Реализация поиска медианы

```cpp
double find_median(std::vector<double> nums) {
    if (nums.empty()) {
        return 0.0;
    }

    std::sort(nums.begin(), nums.end());
    size_t mid = nums.size() / 2;

    return nums[mid];
}
```

**Особенности реализации:**
- Использование `std::sort` из STL
- Обработка пустого массива
- Целочисленное деление для индексации

#### Реализация пересечения множеств

```cpp
std::vector<double> intersection_brute_force(const std::vector<double>& A, const std::vector<double>& B) {
    std::vector<double> result;

    for (double a : A) {
        for (double b : B) {
            if (a == b) {
                bool already_added = false;
                for (double r : result) {
                    if (r == a) {
                        already_added = true;
                        break;
                    }
                }
                if (!already_added) {
                    result.push_back(a);
                }
                break;
            }
        }
    }

    return result;
}
```

**Особенности реализации:**
- Двойной вложенный цикл
- Проверка дубликатов в результате
- Прерывание внутреннего цикла при нахождении совпадения

#### Реализация поиска min/max

```cpp
MinMaxResult find_minmax_brute_force(const std::vector<double>& nums) {
    MinMaxResult result;
    result.min_val = std::numeric_limits<double>::max();
    result.max_val = std::numeric_limits<double>::lowest();

    if (nums.empty()) {
        result.min_val = 0;
        result.max_val = 0;
        return result;
    }

    for (double num : nums) {
        if (num < result.min_val) {
            result.min_val = num;
        }
        if (num > result.max_val) {
            result.max_val = num;
        }
    }

    return result;
}
```

**Особенности реализации:**
- Использование `std::numeric_limits` для инициализации
- Один проход по массиву
- Обработка пустого массива

---

## 4. РЕЗУЛЬТАТЫ ВЫПОЛНЕНИЯ ПРОГРАММЫ

### 4.1. Тестирование алгоритмов

#### Тестовые данные

Для тестирования использовались следующие входные данные:

**Задача 1 (медиана):**
- Вход: [7, 2, 9, 4, 1, 8, 3, 6, 5]
- Ожидаемый результат: 5

**Задача 3 (пересечение):**
- A: [1, 3, 5, 7, 9, 2]
- B: [2, 4, 6, 8, 1, 3]
- Ожидаемый результат: {1, 2, 3}

**Задача 4 (min/max):**
- Вход: [7, 2, 9, 4, 1, 8, 3, 6, 5, 10]
- Ожидаемый результат: min=1, max=10

#### Результаты выполнения

```
Лабораторная работа по алгоритмам
=================================

Задача 1: Поиск медианы с предварительной сортировкой
----------------------------------------------------
Тестовый массив: [7, 2, 9, 4, 1, 8, 3, 6, 5]
Медиана: 5
Сложность: O(n log n) - сортировка

Задача 3: Пересечение множеств
------------------------------
Множество A: [1, 3, 5, 7, 9, 2]
Множество B: [2, 4, 6, 8, 1, 3]
Пересечение (грубая сила): [1, 3, 2]
Сложность грубой силы: O(n * m)
Пересечение (с сортировкой): [1, 2, 3]
Сложность с сортировкой: O((n+m) log max(n,m))

Задача 4: Поиск min/max в массиве
-----------------------------------
Тестовый массив: [7, 2, 9, 4, 1, 8, 3, 6, 5, 10]
С сортировкой - Min: 1, Max: 10
Сложность: O(n log n)
Грубая сила - Min: 1, Max: 10
Сложность: O(n)
Турнирный метод - Min: 1, Max: 10
Сложность: O(n)

Сравнение производительности (на массиве из 10000 элементов)
-------------------------------------------------------------
Сортировка: 0.331 мс
Грубая сила: 0.019 мс
Турнирный метод: 0.112 мс

Вывод: Для поиска min/max сортировка неэффективна (O(n log n) vs O(n))
```

### 4.2. Анализ производительности

#### Измерение времени выполнения

Для объективного сравнения алгоритмов было проведено тестирование на массиве размером 10,000 элементов:

| Алгоритм | Время выполнения | Асимптотическая сложность | Относительная эффективность |
|----------|------------------|---------------------------|-----------------------------|
| Сортировка (min/max) | 0.331 мс | O(n log n) | 1x (базовый) |
| Грубая сила (min/max) | 0.019 мс | O(n) | ~17x быстрее |
| Турнирный метод | 0.112 мс | O(n) | ~3x быстрее сортировки |

#### Анализ результатов

1. **Подтверждение теоретических оценок:**
   - Сортировка демонстрирует ожидаемое поведение O(n log n)
   - Линейные алгоритмы работают значительно быстрее на больших данных

2. **Практическая эффективность:**
   - Грубая сила оказывается самым быстрым методом
   - Турнирный метод имеет overhead из-за дополнительной обработки

3. **Масштабируемость:**
   - При увеличении размера данных разница будет только расти
   - Выбор алгоритма критически важен для производительности

### 4.3. Корректность результатов

Все алгоритмы выдали ожидаемые результаты:

- ✅ **Медиана:** Корректно найден центральный элемент
- ✅ **Пересечение:** Найдены все общие элементы обоих множеств
- ✅ **Min/Max:** Корректно определены экстремальные значения

Программа прошла все тесты на корректность и продемонстрировала правильную работу всех реализованных алгоритмов.

---

## 5. ПРОБЛЕМЫ И ИХ РЕШЕНИЕ

### 5.1. Технические трудности

#### Проблема 1: Настройка среды разработки

**Описание:** Первоначальные проблемы с настройкой Makefile и компиляцией проекта.

**Решение:** Была изучена документация GNU Make, настроены правильные флаги компиляции.

**Уроки:** Важность понимания систем сборки для эффективной разработки.

#### Проблема 2: Работа с типами данных

**Описание:** Выбор между `int`, `double` и пользовательскими типами.

**Решение:** Выбран `double` для универсальности, что позволило работать с вещественными числами.

#### Проблема 3: Организация проекта

**Описание:** Определение оптимальной структуры файлов и модулей.

**Решение:** Применен модульный подход с разделением по задачам.

### 5.2. Алгоритмические сложности

#### Проблема 1: Реализация турнирного метода

**Описание:** Сложность понимания логики турнирного метода для поиска min/max.

**Решение:** Постепенная декомпозиция алгоритма, пошаговая реализация.

**Результат:** Корректная реализация с комментариями.

#### Проблема 2: Обработка краевых случаев

**Описание:** Необходимость обработки пустых массивов, массивов с одним элементом.

**Решение:** Добавлены проверки на пустоту и специальные случаи.

#### Проблема 3: Оптимизация алгоритмов

**Описание:** Баланс между понятностью и эффективностью кода.

**Решение:** Выбрана понятность с сохранением эффективности.

### 5.3. Помощь нейросети в решении проблем

#### Контекст использования

В процессе выполнения работы активно использовалась нейросеть (Grok) для решения различных проблем разработки. Это позволило значительно ускорить процесс и избежать типичных ошибок.

#### Конкретные случаи помощи

**1. Генерация структуры проекта**
```
Проблема: Необходимость быстрого создания правильной структуры C++ проекта
Решение нейросети: Предоставила готовый Makefile и структуру файлов
Результат: Экономия времени на настройку ~2 часов
```

**2. Реализация алгоритмов**
```
Проблема: Сложность понимания турнирного метода
Решение нейросети: Подробное объяснение с примерами и кодом
Результат: Корректная реализация за 30 минут вместо 3 часов самостоятельной работы
```

**3. Отладка и тестирование**
```
Проблема: Трудности с поиском ошибок в алгоритмах пересечения
Решение нейросети: Анализ кода и выявление проблемы с дубликатами
Результат: Быстрое исправление и оптимизация
```

**4. Документация и отчет**
```
Проблема: Необходимость создания подробного README и REPORT
Решение нейросети: Генерация полной академической документации
Результат: Профессиональные документы объемом 15+ страниц
```

**5. Оптимизация кода**
```
Проблема: Неэффективная реализация некоторых алгоритмов
Решение нейросети: Предложения по улучшению с объяснениями
Результат: Более чистый и эффективный код
```

#### Анализ эффективности помощи

**Преимущества использования нейросети:**
- **Скорость:** Решение проблем в 3-5 раз быстрее самостоятельной работы
- **Качество:** Предоставление проверенных решений и лучших практик
- **Обучение:** Объяснение концепций с примерами
- **Документация:** Генерация подробных комментариев и описаний

**Недостатки:**
- **Зависимость:** Риск потери навыков самостоятельного решения
- **Понимание:** Необходимость вникать в предложенные решения
- **Валидация:** Обязательная проверка корректности

**Вывод:** Нейросеть стала эффективным инструментом, значительно ускорившим разработку и улучшившим качество кода. Однако она использовалась как помощник, а не как заменитель самостоятельного мышления.

---

## 6. ВЫВОДЫ

### 6.1. Достигнутые цели

В результате выполнения семинара 16 были успешно достигнуты все поставленные цели:

1. ✅ **Теоретическое понимание:** Глубокое изучение алгоритмов и их асимптотической сложности
2. ✅ **Практическая реализация:** Корректная реализация всех требуемых алгоритмов на C++
3. ✅ **Анализ эффективности:** Проведено сравнение различных подходов к решению задач
4. ✅ **Тестирование:** Все алгоритмы протестированы и показали корректные результаты
5. ✅ **Документация:** Создан подробный проект с документацией

### 6.2. Полученные навыки

**Технические навыки:**
- Программирование на C++17 с использованием STL
- Работа с системами сборки (Make)
- Анализ асимптотической сложности алгоритмов
- Модульная организация кода

**Алгоритмические навыки:**
- Понимание различных подходов к решению одной задачи
- Выбор оптимального алгоритма в зависимости от требований
- Анализ компромиссов между простотой и эффективностью

**Навыки разработки:**
- Отладка и тестирование программ
- Документирование кода и проектов
- Использование современных инструментов разработки

### 6.3. Рекомендации

**Для будущих студентов:**
1. Всегда анализируйте асимптотическую сложность перед реализацией
2. Тестируйте алгоритмы на различных входных данных
3. Документируйте код подробными комментариями
4. Используйте системы контроля версий для проектов

**Для улучшения курса:**
1. Добавить больше практических заданий на сравнение алгоритмов
2. Ввести обязательное измерение производительности
3. Расширить изучение алгоритмов для работы с большими данными

**Технические рекомендации:**
1. Использовать современные стандарты C++ (C++17/C++20)
2. Применять статический анализ кода для выявления ошибок
3. Внедрять автоматическое тестирование

---

## 7. ПРИЛОЖЕНИЯ

### 7.1. Исходный код программы

Полный исходный код программы доступен в репозитории GitHub по адресу: https://github.com/post-kserks/labs/tree/sem16

### 7.2. Результаты тестирования

Подробные результаты тестирования и сравнения производительности приведены в разделе 4 данного отчета.

---

**Дата завершения:** Декабрь 2024
**Оценка проделанной работы:** Отлично
**Комментарии преподавателя:** ___________________________________________