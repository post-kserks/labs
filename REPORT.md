# Отчет по семинару №17
## Тема: Пирамидальная сортировка и свойства кучи (Heap)

### 1. Цели и задачи
**Цель работы:** Изучение структуры данных "Двоичная куча" (Binary Heap) и алгоритмов её построения.

**Задачи:**
1. Реализовать алгоритмы построения кучи:
   - **Восходящий метод** (вставками, sift_up).
   - **Нисходящий метод** (алгоритм Флойда, sift_down).
2. Применить алгоритмы для набора чисел `{1, 8, 6, 5, 3, 7, 4}` и продемонстрировать пошаговый процесс.
3. Проверить гипотезу совпадения результатов обоих методов.
4. Построить пирамиду для символьной последовательности "SORTING".
5. Обосновать (не)устойчивость пирамидальной сортировки.

---

### 2. Ход работы и описание программы

Программа написана на языке C++ и состоит из трех основных модулей:
- `heap.h` — заголовочный файл с описанием функций.
- `heap.cpp` — реализация алгоритмов просеивания и построения.
- `main.cpp` — основная логика тестирования задач семинара.

#### Реализация алгоритмов

**1. Просеивание вниз (Sift Down)**
Основная операция для поддержания свойства кучи (родитель >= детей). Используется в нисходящем построении.

```cpp
void sift_down(std::vector<int>& heap, int index) {
    int max_index = index;
    int left = 2 * index + 1;
    int right = 2 * index + 2;

    if (left < heap.size() && heap[left] > heap[max_index])
        max_index = left;
    
    if (right < heap.size() && heap[right] > heap[max_index])
        max_index = right;

    if (index != max_index) {
        swap(heap[index], heap[max_index]);
        sift_down(heap, max_index); // Рекурсивный спуск
    }
}
```

**2. Восходящее построение (Вставками)**
Элементы добавляются в конец массива по одному, и для каждого вызывается `sift_up`.

```cpp
void build_heap_ascending(std::vector<int>& arr) {
    std::vector<int> heap;
    for (int x : arr) {
        heap.push_back(x);
        sift_up(heap, heap.size() - 1);
        // ... вывод промежуточного состояния ...
    }
    arr = heap;
}
```

**3. Нисходящее построение (Алгоритм Флойда)**
Массив воспринимается как неупорядоченное дерево, операции `sift_down` применяются ко всем узлам от середины к корню.

```cpp
void build_heap_descending(std::vector<int>& arr) {
    for (int i = arr.size() / 2 - 1; i >= 0; --i) {
        sift_down(arr, i);
        // ... вывод промежуточного состояния ...
    }
}
```

---

### 3. Результаты работы программы

При запуске программы для набора чисел `{1, 8, 6, 5, 3, 7, 4}` были получены следующие результаты:

#### 3.1 Восходящий метод
Процесс добавления элементов:
1. `[ 1 ]`
2. `[ 8 1 ]`
3. `[ 8 1 6 ]`
4. `[ 8 5 6 1 ]`
5. `[ 8 5 6 1 3 ]`
6. `[ 8 5 7 1 3 6 ]`
7. `[ 8 5 7 1 3 6 4 ]`

**Результат:** `[ 8 5 7 1 3 6 4 ]`

#### 3.2 Нисходящий метод
Исходный массив: `[ 1 8 6 5 3 7 4 ]`
Процесс просеивания:
1. Просеивание `6`: `[ 1 8 7 5 3 6 4 ]`
2. Просеивание `8`: `[ 1 8 7 5 3 6 4 ]` (без изменений)
3. Просеивание `1`: `[ 8 5 7 1 3 6 4 ]`

**Результат:** `[ 8 5 7 1 3 6 4 ]`

#### 3.3 Сравнение
В данном эксперименте результаты **СОВПАЛИ**.
*Примечание: это частный случай. В общем случае методы могут давать разные (но корректные) пирамиды.*

#### 3.4 Пирамида "SORTING"
Символы были переведены в ASCII коды:
`S(83), O(79), R(82), T(84), I(73), N(78), G(71)`

Построенная пирамида: `[ 84 83 82 79 73 78 71 ]`
В буквах: **`[ T S R O I N G ]`**

Визуализация дерева:
```
      T               
  S       R       
O   I   N   G   
```

---

### 4. Ответы на контрольные вопросы

**Вопрос:** Всегда ли восходящий и нисходящий алгоритмы дают одну и ту же пирамиду?
**Ответ:** Нет. Пример различия: для `[1, 2, 3]` нисходящий метод даст `[3, 2, 1]`, а восходящий `[3, 1, 2]`.

**Вопрос:** Является ли пирамидальная сортировка устойчивой?
**Ответ:** Нет. Обмен корня с последним элементом нарушает относительный порядок равных элементов.

---

### 5. Вывод
В ходе лабораторной работы были успешно реализованы и детально изучены два метода построения двоичной кучи. Продемонстрирован принцип работы каждого метода на числовых примерах и на символьной строке. Экспериментально подтверждена корректность работы реализованных функций. Теоретически обоснована неустойчивость пирамидальной сортировки и отсутствие гарантии идентичности пирамид при разных методах построения.
