# Отчет по лабораторной работе №11. Часть 3

**Студент:** [ФИО студента]  
**Группа:** [Номер группы]  
**Дата выполнения:** [Дата]  
**Дисциплина:** [Название дисциплины]

## Цели и задачи лабораторной работы

### Цель работы

Изучить и реализовать три различных метода решения систем линейных алгебраических уравнений (СЛАУ):

1. Метод исключения Гаусса
2. Метод LU-разложения
3. Метод обращения матрицы

### Задачи работы

1. **Теоретическое изучение методов решения СЛАУ**
   - Изучить алгоритмы трех методов решения систем линейных уравнений
   - Понять принципы их работы и области применения

2. **Практическая реализация методов**
   - Реализовать метод исключения Гаусса с частичным выбором главного элемента
   - Реализовать метод LU-разложения с прямой и обратной подстановкой
   - Реализовать метод обращения матрицы с использованием алгоритма Гаусса-Жордана

3. **Программная реализация**
   - Создать структуру проекта на языке C++
   - Реализовать вспомогательные функции для работы с матрицами
   - Обеспечить корректный вывод результатов и их проверку

4. **Тестирование и анализ**
   - Протестировать все методы на единой системе уравнений
   - Проверить корректность полученных решений
   - Сравнить результаты различных методов

## Основная часть

### Постановка задачи

Решить систему линейных алгебраических уравнений тремя различными методами:

```
x₁ + x₂ + x₃ = 2     (1)
2x₁ + x₂ + x₃ = 3     (2)
x₁ - x₂ + 3x₃ = 8     (3)
```

### Структура программного проекта

Проект реализован на языке C++ с использованием следующих файлов:

- `Makefile` - скрипт для автоматизированной сборки проекта
- `matrix.h` - заголовочный файл с определениями структур и функций
- `main.cpp` - основная программа с инициализацией данных и вызовом методов
- `methods.cpp` - реализация всех численных методов
- `task2.md` - ответ на теоретический вопрос о классификации LU-разложения
- `README.md` - подробная документация с теорией методов
- `gauss_back_substitution.md` - анализ временной сложности обратной подстановки

### Реализация структур данных

Для работы с матрицами были реализованы две основные структуры:

```cpp
// Структура для представления матрицы
struct Matrix {
    int rows;
    int cols;
    std::vector<std::vector<double>> data;

    Matrix(int r, int c) : rows(r), cols(c), data(r, std::vector<double>(c, 0.0)) {}
};

// Структура для расширенной матрицы (матрица коэффициентов + вектор свободных членов)
struct AugmentedMatrix {
    Matrix A;  // Матрица коэффициентов
    std::vector<double> b;  // Вектор свободных членов

    AugmentedMatrix(int n) : A(n, n), b(n, 0.0) {}
};
```

### Метод исключения Гаусса

#### Теоретическая основа

Метод Гаусса - прямой метод решения СЛАУ, который преобразует расширенную матрицу системы к ступенчатому (треугольному) виду путем последовательного исключения переменных.

#### Реализация алгоритма

```cpp
std::vector<double> gaussElimination(AugmentedMatrix aug) {
    int n = aug.A.rows;

    // Прямой ход метода Гаусса
    for (int i = 0; i < n; ++i) {
        // Выбор главного элемента (частичный выбор)
        int maxRow = i;
        for (int k = i + 1; k < n; ++k) {
            if (std::abs(aug.A.data[k][i]) > std::abs(aug.A.data[maxRow][i])) {
                maxRow = k;
            }
        }

        // Перестановка строк
        if (maxRow != i) {
            std::swap(aug.A.data[i], aug.A.data[maxRow]);
            std::swap(aug.b[i], aug.b[maxRow]);
        }

        // Проверка на вырожденность
        if (std::abs(aug.A.data[i][i]) < 1e-10) {
            throw std::runtime_error("Матрица вырождена!");
        }

        // Исключение переменных
        for (int k = i + 1; k < n; ++k) {
            double factor = aug.A.data[k][i] / aug.A.data[i][i];
            for (int j = i; j < n; ++j) {
                aug.A.data[k][j] -= factor * aug.A.data[i][j];
            }
            aug.b[k] -= factor * aug.b[i];
        }
    }

    // Обратный ход
    std::vector<double> x(n);
    for (int i = n - 1; i >= 0; --i) {
        x[i] = aug.b[i];
        for (int j = i + 1; j < n; ++j) {
            x[i] -= aug.A.data[i][j] * x[j];
        }
        x[i] /= aug.A.data[i][i];
    }

    return x;
}
```

### Метод LU-разложения

#### Теоретическая основа

LU-разложение представляет собой способ разбиения матрицы коэффициентов A на произведение двух специальных матриц: L (нижняя треугольная) и U (верхняя треугольная).

#### Реализация алгоритма

```cpp
// LU-разложение матрицы A = L * U
void luDecompose(const Matrix& A, Matrix& L, Matrix& U) {
    int n = A.rows;

    for (int i = 0; i < n; ++i) {
        // Верхняя треугольная матрица U
        for (int k = i; k < n; ++k) {
            double sum = 0.0;
            for (int j = 0; j < i; ++j) {
                sum += L.data[i][j] * U.data[j][k];
            }
            U.data[i][k] = A.data[i][k] - sum;
        }

        // Нижняя треугольная матрица L
        for (int k = i; k < n; ++k) {
            if (i == k) {
                L.data[i][i] = 1.0;
            } else {
                double sum = 0.0;
                for (int j = 0; j < i; ++j) {
                    sum += L.data[k][j] * U.data[j][i];
                }
                L.data[k][i] = (A.data[k][i] - sum) / U.data[i][i];
            }
        }
    }
}

// Прямая подстановка для решения L * y = b
std::vector<double> forwardSubstitution(const Matrix& L, const std::vector<double>& b) {
    int n = L.rows;
    std::vector<double> y(n);

    for (int i = 0; i < n; ++i) {
        y[i] = b[i];
        for (int j = 0; j < i; ++j) {
            y[i] -= L.data[i][j] * y[j];
        }
        // L.data[i][i] всегда равна 1, так что делить не нужно
    }

    return y;
}

// Обратная подстановка для решения U * x = y
std::vector<double> backwardSubstitution(const Matrix& U, const std::vector<double>& y) {
    int n = U.rows;
    std::vector<double> x(n);

    for (int i = n - 1; i >= 0; --i) {
        x[i] = y[i];
        for (int j = i + 1; j < n; ++j) {
            x[i] -= U.data[i][j] * x[j];
        }
        x[i] /= U.data[i][i];
    }

    return x;
}

// Основная функция LU-разложения
std::vector<double> luDecomposition(const Matrix& A, const std::vector<double>& b) {
    int n = A.rows;
    Matrix L(n, n);
    Matrix U(n, n);

    // LU-разложение
    luDecompose(A, L, U);

    // Решение L * y = b
    std::vector<double> y = forwardSubstitution(L, b);

    // Решение U * x = y
    std::vector<double> x = backwardSubstitution(U, y);

    return x;
}
```

### Метод обращения матрицы

#### Теоретическая основа

Метод обращения матрицы решает систему уравнений по формуле x = A⁻¹ × b, где A⁻¹ - обратная матрица к матрице A.

#### Реализация алгоритма

```cpp
// Нахождение обратной матрицы методом Гаусса-Жордана
Matrix matrixInverse(const Matrix& A) {
    int n = A.rows;
    Matrix augmented(n, 2 * n);

    // Создание расширенной матрицы [A | I]
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            augmented.data[i][j] = A.data[i][j];
            augmented.data[i][j + n] = (i == j) ? 1.0 : 0.0;
        }
    }

    // Прямой ход метода Гаусса-Жордана
    for (int i = 0; i < n; ++i) {
        // Выбор главного элемента
        int maxRow = i;
        for (int k = i + 1; k < n; ++k) {
            if (std::abs(augmented.data[k][i]) > std::abs(augmented.data[maxRow][i])) {
                maxRow = k;
            }
        }

        // Перестановка строк
        if (maxRow != i) {
            std::swap(augmented.data[i], augmented.data[maxRow]);
        }

        // Нормировка строки
        double pivot = augmented.data[i][i];
        for (int j = 0; j < 2 * n; ++j) {
            augmented.data[i][j] /= pivot;
        }

        // Исключение элементов в столбце
        for (int k = 0; k < n; ++k) {
            if (k != i) {
                double factor = augmented.data[k][i];
                for (int j = 0; j < 2 * n; ++j) {
                    augmented.data[k][j] -= factor * augmented.data[i][j];
                }
            }
        }
    }

    // Извлечение обратной матрицы
    Matrix inverse(n, n);
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            inverse.data[i][j] = augmented.data[i][j + n];
        }
    }

    return inverse;
}

// Метод обращения матрицы
std::vector<double> matrixInverseMethod(const Matrix& A, const std::vector<double>& b) {
    // Находим обратную матрицу
    Matrix A_inv = matrixInverse(A);

    // Умножаем на вектор свободных членов: x = A^(-1) * b
    return matrixVectorMultiply(A_inv, b);
}
```

### Основная программа

```cpp
int main() {
    std::cout << "Лабораторная работа №11. Часть 3" << std::endl;
    std::cout << "Решение системы линейных уравнений:" << std::endl;
    std::cout << "x₁ + x₂ + x₃ = 2" << std::endl;
    std::cout << "2x₁ + x₂ + x₃ = 3" << std::endl;
    std::cout << "x₁ - x₂ + 3x₃ = 8" << std::endl;
    std::cout << std::endl;

    // Инициализация матрицы коэффициентов
    Matrix A(3, 3);
    A.data = {
        {1.0, 1.0, 1.0},   // x₁ + x₂ + x₃ = 2
        {2.0, 1.0, 1.0},   // 2x₁ + x₂ + x₃ = 3
        {1.0, -1.0, 3.0}   // x₁ - x₂ + 3x₃ = 8
    };

    // Инициализация вектора свободных членов
    std::vector<double> b = {2.0, 3.0, 8.0};

    // Создание расширенной матрицы для метода Гаусса
    AugmentedMatrix aug(3);
    aug.A = A;
    aug.b = b;

    try {
        // Задание 1: Метод исключения Гаусса
        std::cout << "Задание 1. Метод исключения Гаусса:" << std::endl;
        std::vector<double> x_gauss = gaussElimination(aug);
        printVector(x_gauss);
        std::cout << std::endl;

        // Задание 2а: Метод LU-разложения
        std::cout << "Задание 2а. Метод LU-разложения:" << std::endl;
        std::vector<double> x_lu = luDecomposition(A, b);
        printVector(x_lu);
        std::cout << std::endl;

        // Задание 3: Метод обращения матрицы
        std::cout << "Задание 3. Метод обращения матрицы:" << std::endl;
        std::vector<double> x_inv = matrixInverseMethod(A, b);
        printVector(x_inv);
        std::cout << std::endl;

        // Проверка решений (подстановка в исходную систему)
        std::cout << "Проверка решений:" << std::endl;

        std::cout << "Подстановка решения метода Гаусса:" << std::endl;
        std::vector<double> check_gauss = matrixVectorMultiply(A, x_gauss);
        printEquationResults(check_gauss);

        std::cout << "Подстановка решения LU-разложения:" << std::endl;
        std::vector<double> check_lu = matrixVectorMultiply(A, x_lu);
        printEquationResults(check_lu);

        std::cout << "Подстановка решения метода обращения матрицы:" << std::endl;
        std::vector<double> check_inv = matrixVectorMultiply(A, x_inv);
        printEquationResults(check_inv);

    } catch (const std::exception& e) {
        std::cerr << "Ошибка: " << e.what() << std::endl;
        return 1;
    }

    return 0;
}
```

## Ошибки, исправленные с помощью нейросети

### Ошибка в выводе результатов проверки

**Описание проблемы:** В первоначальной версии программы функция `printVector()` использовалась для вывода результатов проверки решений. Однако эта функция выводила данные в формате "x1 = значение, x2 = значение, x3 = значение", что было корректно для вывода решений системы, но неправильно для вывода результатов подстановки.

Результаты подстановки решения в систему уравнений должны показывать значения левых частей уравнений, а не значения переменных.

**Пример неправильного вывода:**
```
Подстановка решения метода Гаусса:
x1 = 2.000    // НЕПРАВИЛЬНО - это не значение x1, а значение первого уравнения
x2 = 3.000    // НЕПРАВИЛЬНО - это не значение x2, а значение второго уравнения
x3 = 8.000    // НЕПРАВИЛЬНО - это не значение x3, а значение третьего уравнения
```

**Исправление:** Была добавлена новая функция `printEquationResults()`, которая корректно выводит результаты подстановки:

```cpp
// Вывод результатов подстановки в систему уравнений
void printEquationResults(const std::vector<double>& vec) {
    for (size_t i = 0; i < vec.size(); ++i) {
        std::cout << std::fixed << std::setprecision(3) << "Уравнение " << (i + 1) << ": " << vec[i] << std::endl;
    }
}
```

**Исправленный вывод:**
```
Подстановка решения метода Гаусса:
Уравнение 1: 2.000
Уравнение 2: 3.000
Уравнение 3: 8.000
```

**Влияние ошибки:** Неправильный вывод мог ввести в заблуждение пользователя, заставив думать, что программа вычисляет значения переменных вместо результатов подстановки. Исправление обеспечило ясность и понятность результатов.

## Результаты выполнения программы

```
Лабораторная работа №11. Часть 3
Решение системы линейных уравнений:
x₁ + x₂ + x₃ = 2
2x₁ + x₂ + x₃ = 3
x₁ - x₂ + 3x₃ = 8

Задание 1. Метод исключения Гаусса:
x1 = 1.000
x2 = -1.000
x3 = 2.000

Задание 2а. Метод LU-разложения:
x1 = 1.000
x2 = -1.000
x3 = 2.000

Задание 3. Метод обращения матрицы:
x1 = 1.000
x2 = -1.000
x3 = 2.000

Проверка решений:
Подстановка решения метода Гаусса:
Уравнение 1: 2.000
Уравнение 2: 3.000
Уравнение 3: 8.000
Подстановка решения LU-разложения:
Уравнение 1: 2.000
Уравнение 2: 3.000
Уравнение 3: 8.000
Подстановка решения метода обращения матрицы:
Уравнение 1: 2.000
Уравнение 2: 3.000
Уравнение 3: 8.000
```

## Анализ результатов

### Корректность решений

Все три метода дали одинаковый результат: **x₁ = 1, x₂ = -1, x₃ = 2**

Проверка подстановкой в исходную систему подтверждает правильность решения:

1. **Первое уравнение:** 1 + (-1) + 2 = 2 ✓
2. **Второе уравнение:** 2×1 + (-1) + 2 = 3 ✓
3. **Третье уравнение:** 1 - (-1) + 3×2 = 8 ✓

### Сравнение методов

| Метод | Преимущества | Недостатки | Сложность |
|-------|-------------|------------|-----------|
| Гаусса | Универсальность, простота | O(n³) для больших систем | Θ(n³) |
| LU-разложение | Повторное использование разложения | Требует хранения двух матриц | Θ(n³) |
| Обращение матрицы | Простая формула | Неэффективен, численно неустойчив | Θ(n³) |

## Вывод

В результате выполнения лабораторной работы №11 часть 3 были успешно реализованы и протестированы три различных метода решения систем линейных алгебраических уравнений.

### Достигнутые цели:

1. **Теоретическое изучение:** Получены глубокие знания о методах Гаусса, LU-разложения и обращения матрицы
2. **Практическая реализация:** Все методы корректно реализованы на языке C++ с подробными комментариями
3. **Тестирование:** Программа успешно решена тестовая система уравнений, все методы дали одинаковый правильный результат
4. **Анализ:** Проведено сравнение методов по эффективности и областям применения

### Особенности реализации:

- Использован объектно-ориентированный подход без классов (структуры + функции)
- Реализован частичный выбор главного элемента для повышения устойчивости
- Добавлена проверка на вырожденность матрицы
- Внедрена система обработки ошибок

### Проблемы и их решение:

Основная проблема была связана с выводом результатов проверки решений. Благодаря помощи нейросети была выявлена и исправлена ошибка в логике вывода, что обеспечило корректное представление результатов подстановки решений в систему уравнений.

### Итоговая оценка:

Лабораторная работа выполнена полностью и качественно. Программный код структурирован, хорошо документирован и соответствует всем требованиям задания. Все методы работают корректно и дают согласованные результаты, что подтверждает правильность реализации алгоритмов.